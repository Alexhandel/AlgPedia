ABOUT
In job shop scheduling and graph drawing, the Coffman–Graham algorithm is an algorithm, named after Edward G. Coffman, Jr. and Ronald Graham, for arranging the elements of a partially ordered set into a sequence of levels. The algorithm chooses an arrangement such that an element that comes after another in the order is assigned to a lower level, and such that each level has a number of elements that does not exceed a fixed width bound W. When W = 2, it uses the minimum possible number of distinct levels,[1] and in general it uses at most 2 − 2/W times as many levels as necessary.[2][3]
FULL TEXT
In job shop scheduling and graph drawing, the Coffman–Graham algorithm is an algorithm, named after Edward G. Coffman, Jr. and Ronald Graham, for arranging the elements of a partially ordered set into a sequence of levels. The algorithm chooses an arrangement such that an element that comes after another in the order is assigned to a lower level, and such that each level has a number of elements that does not exceed a fixed width bound W. When W = 2, it uses the minimum possible number of distinct levels,[1] and in general it uses at most 2 − 2/W times as many levels as necessary.[2][3]


In the version of the job shop scheduling problem solved by the Coffman–Graham algorithm, one is given a set of n jobs J1, J2, ..., Jn, together with a system of precedence constraints Ji < Jj requiring that job Ji be completed before job Jj begins. Each job is assumed to take unit time to complete. The scheduling task is to assign each of these jobs to time slots on a system of W identical processors, minimizing the makespan of the assignment (the time from the beginning of the first job until the completion of the final job). Abstractly, the precedence constraints define a partial order on the jobs, so the problem can be rephrased as one of assigning the elements of this partial order to levels (time slots) in such a way that each time slot has at most as many jobs as processors (at most W elements per level), respecting the precedence constraints. This application was the original motivation for Coffman and Graham to develop their algorithm.[1][4]
In the layered graph drawing framework outlined by Sugiyama, Tagawa & Toda (1981)[5] the input is a directed graph, and a drawing of a graph is constructed in several stages:[6][7]
In this framework, the y-coordinate assignment again involves grouping elements of a partially ordered set (the vertices of the graph, with the reachability ordering on the vertex set) into layers (sets of vertices with the same y-coordinate), which is the problem solved by the Coffman–Graham algorithm.[6] Although there exist alternative approaches than the Coffman–Graham algorithm to the layering step, these alternatives in general are either not able to incorporate a bound on the maximum width of a level or rely on complex integer programming procedures.[8]
More abstractly, both of these problems can be formalized as a problem in which the input consists of a partially ordered set and an integer W. The desired output is an assignment of integer level numbers to the elements of the partially ordered set such that, if x < y is an ordered pair of related elements of the partial order, the number assigned to x is smaller than the number assigned to y, such that at most W elements are assigned the same number as each other, and minimizing the difference between the smallest and the largest assigned numbers.
The Coffman–Graham algorithm performs the following steps.[6]
As Coffman & Graham (1972) originally proved, their algorithm computes an optimal assignment for W = 2; that is, for scheduling problems with unit length jobs on two processors, or for layered graph drawing problems with at most two vertices per layer.[1] A closely related algorithm also finds the optimal solution for scheduling of jobs with varying lengths, allowing pre-emption of scheduled jobs, on two processors.[9] For W > 2, the Coffman–Graham algorithm uses a number of levels (or computes a schedule with a makespan) that is within a factor of 2 − 2/W of optimal.[2][3] For instance, for W = 3, this means that it uses at most 4/3 times as many levels as is optimal. When the partial order of precedence constraints is an interval order, or belongs to several related classes of partial orders, the Coffman–Graham algorithm finds a solution with the minimum number of levels regardless of its width bound.[10]
As well as finding schedules with small makespan, the Coffman–Graham algorithm (modified from the presentation here so that it topologically orders the reverse graph of G and places the vertices as early as possible rather than as late as possible) minimizes the total flow time of two-processor schedules, the sum of the completion times of the individual jobs. A related algorithm can be used to minimize the total flow time for a version of the problem in which preemption of jobs is allowed.[11]
Coffman & Graham (1972) and Lenstra & Rinnooy Kan (1978)[12] state the time complexity of the Coffman–Graham algorithm, on an n-element partial order, to be O(n2). However, this analysis omits the time for constructing the transitive reduction, which is not known to be possible within this bound. Sethi (1976) shows how to implement the topological ordering stage of the algorithm in linear time, based on the idea of partition refinement.[13] Sethi also shows how to implement the level assignment stage of the algorithm efficiently by using a disjoint-set data structure. In particular, with a version of this structure published later by Gabow & Tarjan (1985), this stage also takes linear time.[14]