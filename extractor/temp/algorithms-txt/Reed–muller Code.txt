ABOUT
Reed–Muller codes are a family of linear error-correcting codes used in communications. Reed–Muller codes belong to the classes of locally testable codes and locally decodable codes, which is why they are useful in the design of probabilistically checkable proofs in computational complexity theory. They are named after Irving S. Reed and David E. Muller. Muller discovered the codes, and Reed proposed the majority logic decoding for the first time. Special cases of Reed–Muller codes include the Walsh–Hadamard code and the Reed–Solomon code.
FULL TEXT
Reed–Muller codes are a family of linear error-correcting codes used in communications. Reed–Muller codes belong to the classes of locally testable codes and locally decodable codes, which is why they are useful in the design of probabilistically checkable proofs in computational complexity theory. They are named after Irving S. Reed and David E. Muller. Muller discovered the codes, and Reed proposed the majority logic decoding for the first time. Special cases of Reed–Muller codes include the Walsh–Hadamard code and the Reed–Solomon code.
Reed–Muller codes are listed as RM(r, m), where r is the order of the code, 0 ≤ r ≤ m, and m determines the code length N = 2 m. RM codes are related to binary functions on the field GF(2 m) over the elements {0, 1}.
RM(0, m) codes are repetition codes of length N = 2 m, rate 




R
=



1
N






{\displaystyle {R={\tfrac {1}{N}}}}

 and minimum distance dmin = N.
RM(1, m) codes are parity check codes of length N = 2 m, rate 



R
=




m
+
1

N





{\displaystyle R={\tfrac {m+1}{N}}}

 and minimum distance 




d

min


=



N
2





{\displaystyle d_{\min }={\tfrac {N}{2}}}

.
RM(m − 1, m) codes are single parity check codes of length N = 2 m, rate 



R
=




N
−
1

N





{\displaystyle R={\tfrac {N-1}{N}}}

 and minimum distance 




d

min


=
2


{\displaystyle d_{\min }=2}

.
RM(m − 2, m) codes are the family of extended Hamming codes of length N = 2 m with minimum distance dmin = 4.[1]


A generator matrix for a Reed–Muller code RM(r,m) of length N = 2m can be constructed as follows. Let us write the set of all m-dimensional binary vectors as:
We define in N-dimensional space 





F


2


N




{\displaystyle \mathbb {F} _{2}^{N}}

 the indicator vectors
on subsets 



A
⊂
X


{\displaystyle A\subset X}

 by:
together with, also in 





F


2


N




{\displaystyle \mathbb {F} _{2}^{N}}

, the binary operation
referred to as the wedge product (this wedge product is not to be confused with the wedge product defined in exterior algebra). Here, 



w
=
(

w

1


,

w

2


,
…
,

w

N


)


{\displaystyle w=(w_{1},w_{2},\ldots ,w_{N})}

 and 



z
=
(

z

1


,

z

2


,
…
,

z

N


)


{\displaystyle z=(z_{1},z_{2},\ldots ,z_{N})}

 are points in 





F


2


N




{\displaystyle \mathbb {F} _{2}^{N}}

 (N-dimensional binary vectors), and the operation 



⋅


{\displaystyle \cdot }

 is the usual multiplication in the field 





F


2




{\displaystyle \mathbb {F} _{2}}

.






F


2


m




{\displaystyle \mathbb {F} _{2}^{m}}

 is an m-dimensional vector space over the field 





F


2




{\displaystyle \mathbb {F} _{2}}

, so it is possible to write




(


F


2



)

m


=
{
(

y

m


,
…
,

y

1


)
∣

y

i


∈


F


2


}


{\displaystyle (\mathbb {F} _{2})^{m}=\{(y_{m},\ldots ,y_{1})\mid y_{i}\in \mathbb {F} _{2}\}}


We define in N-dimensional space 





F


2


N




{\displaystyle \mathbb {F} _{2}^{N}}

 the following vectors with length 



N
:

v

0


=
(
1
,
1
,
…
,
1
)


{\displaystyle N:v_{0}=(1,1,\ldots ,1)}

 and
where 1 ≤ i ≤ m and the Hi are hyperplanes in 



(


F


2



)

m




{\displaystyle (\mathbb {F} _{2})^{m}}

 (with dimension m −1):
The Reed–Muller RM(r, m) code of order r and length N = 2m is the code generated by v0 and the wedge products of up to r of the vi, 1 ≤ i ≤ m (where by convention a wedge product of fewer than one vector is the identity for the operation). In other words, we can build a generator matrix for the RM(r,m) code, using vectors and their wedge product permutations up to r at a time 





v

0


,

v

1


,
…
,

v

n


,
…
,
(

v


i

1




∧

v


i

2




)
,
…
(

v


i

1




∧

v


i

2




…
∧

v


i

r




)



{\displaystyle {v_{0},v_{1},\ldots ,v_{n},\ldots ,(v_{i_{1}}\wedge v_{i_{2}}),\ldots (v_{i_{1}}\wedge v_{i_{2}}\ldots \wedge v_{i_{r}})}}

, as the rows of the generator matrix, where 1 ≤ ik ≤ m.
Let m = 3. Then N = 8, and
and
The RM(1,3) code is generated by the set
or more explicitly by the rows of the matrix
The RM(2,3) code is generated by the set:
or more explicitly by the rows of the matrix:
The following properties hold:
1 The set of all possible wedge products of up to m of the vi form a basis for 





F


2


N




{\displaystyle \mathbb {F} _{2}^{N}}

.
2 The RM (r, m) code has rank
3 RM (r, m) = RM (r, m − 1) | RM (r − 1, m − 1) where '|' denotes the bar product of two codes.
4 RM (r, m) has minimum Hamming weight 2m − r.
1
2
3
4
A Reed–Muller code RM(r,m) exists for any integers 



m
≥
0


{\displaystyle m\geq 0}

 and 



0
≤
r
≤
m


{\displaystyle 0\leq r\leq m}

. RM(m, m) is defined as the universe (




2

m


,

2

m


,
1


{\displaystyle 2^{m},2^{m},1}

) code. RM(−1,m) is defined as the trivial code (




2

m


,
0
,
∞


{\displaystyle 2^{m},0,\infty }

). The remaining RM codes may be constructed from these elementary codes using the length-doubling construction
From this construction, RM(r,m) is a binary linear block code (n, k, d) with length n = 2 m, dimension 



k
(
r
,
m
)
=
k
(
r
,
m
−
1
)
+
k
(
r
−
1
,
m
−
1
)


{\displaystyle k(r,m)=k(r,m-1)+k(r-1,m-1)}

 and minimum distance 



d
=

2

m
−
r




{\displaystyle d=2^{m-r}}

 for 



r
≥
0


{\displaystyle r\geq 0}

. The dual code to RM(r,m) is RM(m-r-1,m). This shows that repetition and SPC codes are duals, biorthogonal and extended Hamming codes are duals and that codes with k = n/2 are self-dual.
There is another, simple way to construct Reed–Muller codes based on low-degree polynomials over a finite field. This construction is particularly suited for their application as locally testable codes and locally decodable codes.[2]
Let 




F



{\displaystyle \mathbb {F} }

 be a finite field and let 



m


{\displaystyle m}

 and 



d


{\displaystyle d}

 be positive integers, where 



m


{\displaystyle m}

 should be thought of as larger than 



d


{\displaystyle d}

. We are going to encode messages consisting of 






(



m
+
d

m


)





{\displaystyle {m+d \choose m}}

 elements of 




F



{\displaystyle \mathbb {F} }

 as codewords of length 




|


F



|


m




{\displaystyle |\mathbb {F} |^{m}}

 as follows: We interpret the message as an 



m


{\displaystyle m}

-variate polynomial 



f


{\displaystyle f}

 of degree at most 



d


{\displaystyle d}

 with coefficient from 




F



{\displaystyle \mathbb {F} }

. Such a polynomial has 






(



m
+
d

m


)





{\displaystyle {m+d \choose m}}

 coefficients. The Reed–Muller encoding of 



f


{\displaystyle f}

 is the list of the evaluations of 



f


{\displaystyle f}

 on all 



x
∈


F


m




{\displaystyle x\in \mathbb {F} ^{m}}

; the codeword at the position indexed by 



x
∈


F


m




{\displaystyle x\in \mathbb {F} ^{m}}

 has value 



f
(
x
)


{\displaystyle f(x)}

.
The table below lists the RM(r, m) codes of lengths up to 32.
RM(r, m) codes can be decoded using majority logic decoding. The basic idea of majority logic decoding is to build several checksums for each received code word element. Since each of the different checksums must all have the same value (i.e. the value of the message word element weight), we can use a majority logic decoding to decipher the value of the message word element. Once each order of the polynomial is decoded, the received word is modified accordingly by removing the corresponding codewords weighted by the decoded message contributions, up to the present stage. So for a rth order RM code, we have to decode iteratively r+1, times before we arrive at the final received code-word. Also, the values of the message bits are calculated through this scheme; finally we can calculate the codeword by multiplying the message word (just decoded) with the generator matrix.
One clue if the decoding succeeded, is to have an all-zero modified received word, at the end of (r + 1)-stage decoding through the majority logic decoding. This technique was proposed by Irving S. Reed, and is more general when applied to other finite geometry codes.
Research Articles:
Textbooks: