{
    "about": "The Berlekamp\u2013Welch algorithm, also known as the Welch\u2013Berlekamp algorithm, is named for Elwyn R. Berlekamp and Lloyd R. Welch. The algorithm efficiently corrects errors in BCH codes and Reed\u2013Solomon codes (which are a subset of BCH codes). Unlike many other decoding algorithms, and in correspondence with the code-domain Berlekamp\u2013Massey algorithm that uses syndrome decoding and the dual of the codes, the Berlekamp\u2013Welch decoding algorithm provides a method for decoding Reed\u2013Solomon codes using just the generator matrix and not syndromes.", 
    "name": "Berlekamp\u2013Welch Algorithm", 
    "classification": "Error Detection And Correction", 
    "full_text": "The Berlekamp\u2013Welch algorithm, also known as the Welch\u2013Berlekamp algorithm, is named for Elwyn R. Berlekamp and Lloyd R. Welch. The algorithm efficiently corrects errors in BCH codes and Reed\u2013Solomon codes (which are a subset of BCH codes). Unlike many other decoding algorithms, and in correspondence with the code-domain Berlekamp\u2013Massey algorithm that uses syndrome decoding and the dual of the codes, the Berlekamp\u2013Welch decoding algorithm provides a method for decoding Reed\u2013Solomon codes using just the generator matrix and not syndromes.\n\n\nIn the problem of decoding Reed\u2013Solomon codes, the inputs are pair wise distinct evaluation points \n\n\n\n\n\u03b1\n\n1\n\n\n,\n\u22ef\n,\n\n\u03b1\n\nn\n\n\n\n\n{\\displaystyle \\alpha _{1},\\cdots ,\\alpha _{n}}\n\n where \n\n\n\n\n\u03b1\n\ni\n\n\n\u2208\n\nF\n\n\n\n{\\displaystyle \\alpha _{i}\\in \\mathbb {F} }\n\n with dimension \n\n\n\nk\n\n\n{\\displaystyle k}\n\n and distance \n\n\n\nd\n=\nn\n\u2212\nk\n+\n1\n\n\n{\\displaystyle d=n-k+1}\n\n and a codeword \n\n\n\ny\n=\n(\n\ny\n\n1\n\n\n,\n\u22ef\n,\n\ny\n\nn\n\n\n)\n\u2208\n\n\nF\n\n\nn\n\n\n.\n\n\n{\\displaystyle y=(y_{1},\\cdots ,y_{n})\\in \\mathbb {F} ^{n}.}\n\n Our goal is to describe an algorithm that can correct \n\n\n\ne\n<\n\n\n\n1\n2\n\n\n\n(\nn\n\u2212\nk\n+\n1\n)\n\n\n{\\displaystyle e<{\\tfrac {1}{2}}(n-k+1)}\n\n many errors in polynomial time. To do so we have to find \n\n\n\nP\n\u2208\n\nF\n\n[\nX\n]\n\n\n{\\displaystyle P\\in \\mathbb {F} [X]}\n\n such that \n\n\n\ndeg\n\u2061\n(\nP\n)\n<\nk\n\u2212\n1\n\n\n{\\displaystyle \\deg(P)<k-1}\n\n and the number of indices for which \n\n\n\nP\n(\n\n\u03b1\n\ni\n\n\n)\n\u2260\n\ny\n\ni\n\n\n\n\n{\\displaystyle P(\\alpha _{i})\\neq y_{i}}\n\n is less than or equal to \n\n\n\ne\n.\n\n\n{\\displaystyle e.}\n\n We can assume that there exists a polynomial \n\n\n\nP\n\n\n{\\displaystyle P}\n\n such that\nNote that the coefficients of \n\n\n\nP\n\n\n{\\displaystyle P}\n\n are the encoded information. To solve this, we use an indicator for those indices where an error may have occurred. Thus we define an error locator polynomial, \n\n\n\nE\n\u2208\n\nF\n\n[\nX\n]\n,\n\n\n{\\displaystyle E\\in \\mathbb {F} [X],}\n\n by:\nNote that \n\n\n\ndeg\n\u2061\n(\nE\n)\n\u2a7d\n\n\n\n1\n2\n\n\n\n(\nn\n\u2212\nk\n)\n.\n\n\n{\\displaystyle \\deg(E)\\leqslant {\\tfrac {1}{2}}(n-k).}\n\n We can also claim that \n\n\n\n\ny\n\ni\n\n\nE\n(\n\n\u03b1\n\ni\n\n\n)\n=\nP\n(\n\n\u03b1\n\ni\n\n\n)\nE\n(\n\n\u03b1\n\ni\n\n\n)\n\n\n{\\displaystyle y_{i}E(\\alpha _{i})=P(\\alpha _{i})E(\\alpha _{i})}\n\n holds for all \n\n\n\n1\n\u2a7d\ni\n\u2a7d\nn\n\n\n{\\displaystyle 1\\leqslant i\\leqslant n}\n\n. This fact holds true because in the event of \n\n\n\n\ny\n\ni\n\n\n\u2260\nP\n(\n\n\u03b1\n\ni\n\n\n)\n\n\n{\\displaystyle y_{i}\\neq P(\\alpha _{i})}\n\n, both sides of the above equation vanish because \n\n\n\nE\n(\n\n\u03b1\n\ni\n\n\n)\n=\n0\n\n\n{\\displaystyle E(\\alpha _{i})=0}\n\n.\nHowever, since \n\n\n\nE\n\n\n{\\displaystyle E}\n\n and \n\n\n\nP\n\n\n{\\displaystyle P}\n\n are both unknown, the main task of the decoding algorithm would be to find \n\n\n\nP\n\n\n{\\displaystyle P}\n\n. To do this we use a seemingly useless yet very powerful method and define another polynomial \n\n\n\nQ\n=\nP\nE\n.\n\n\n{\\displaystyle Q=PE.}\n\n This is because the \n\n\n\nn\n\n\n{\\displaystyle n}\n\n equations with \n\n\n\ne\n+\nk\n\n\n{\\displaystyle e+k}\n\n we need to solve are quadratic in nature. Thus by defining a product of two variables that gives rise to a quadratic term as one unknown variable, we increase the number of unknowns but make the equations linear in nature. This method is called linearization[7] and is a very powerful tool.\nThus \n\n\n\nQ\n\u2208\n\nF\n\n[\nX\n]\n\n\n{\\displaystyle Q\\in \\mathbb {F} [X]}\n\n having the properties:\nThis helps because if we now manage to find \n\n\n\nQ\n\n\n{\\displaystyle Q}\n\n and \n\n\n\nE\n\n\n{\\displaystyle E}\n\n, we can easily find \n\n\n\nP\n\n\n{\\displaystyle P}\n\n using \n\n\n\nP\n=\n\n\n\nQ\nE\n\n\n\n\n\n{\\displaystyle P={\\tfrac {Q}{E}}}\n\n. The main purpose of the Berlekamp Welch algorithm is to find out \n\n\n\nP\n\n\n{\\displaystyle P}\n\n using degree bounded polynomials \n\n\n\nQ\n\n\n{\\displaystyle Q}\n\n and \n\n\n\nE\n\n\n{\\displaystyle E}\n\n and the properties of \n\n\n\nE\n\n\n{\\displaystyle E}\n\n and \n\n\n\nN\n\n\n{\\displaystyle N}\n\n.\nComputing \n\n\n\nE\n\n\n{\\displaystyle E}\n\n is as hard as finding the end solution \n\n\n\nP\n.\n\n\n{\\displaystyle P.}\n\n Once \n\n\n\nE\n\n\n{\\displaystyle E}\n\n is computed, using erasure decoding for Reed\u2013Solomon codes, we can easily recover \n\n\n\nP\n\n\n{\\displaystyle P}\n\n. However, in a few cases, even the polynomial \n\n\n\nQ\n\n\n{\\displaystyle Q}\n\n is as hard to find as \n\n\n\nE\n\n\n{\\displaystyle E}\n\n. As an example, given \n\n\n\nQ\n\n\n{\\displaystyle Q}\n\n and \n\n\n\ny\n\n\n{\\displaystyle y}\n\n (such that \n\n\n\n\ny\n\ni\n\n\n\u2260\n0\n\n\n{\\displaystyle y_{i}\\neq 0}\n\n for \n\n\n\n1\n\u2a7d\ni\n\u2a7d\nn\n\n\n{\\displaystyle 1\\leqslant i\\leqslant n}\n\n), by checking positions where \n\n\n\nQ\n(\ni\n)\n=\n0\n\n\n{\\displaystyle Q(i)=0}\n\n, we can \ufb01nd the error locations. Thus the algorithm works on the principle that while each of the polynomials \n\n\n\nE\n\n\n{\\displaystyle E}\n\n and \n\n\n\nQ\n\n\n{\\displaystyle Q}\n\n are hard to find individually; computing them together is much easier.\nThe Welch\u2013Berlekamp decoder for Reed\u2013Solomon codes consists of the Welch\u2013 Berlekamp algorithm augmented by some additional steps that prepare the received word for the algorithm and interpret the result of the algorithm.\nThe inputs given to the Berlekamp Welch decoder are the integers denoting Block Length \n\n\n\nn\n,\n\n\n{\\displaystyle n,}\n\n the number of errors \n\n\n\ne\n\n\n{\\displaystyle e}\n\n such that \n\n\n\ne\n<\n\n\n\n1\n2\n\n\n\n(\nn\n\u2212\nk\n+\n1\n)\n,\n\n\n{\\displaystyle e<{\\tfrac {1}{2}}(n-k+1),}\n\n and the received word \n\n\n\n(\n\ny\n\ni\n\n\n,\n\n\u03b1\n\ni\n\n\n\n)\n\ni\n=\n1\n\n\nn\n\n\n\n\n{\\displaystyle (y_{i},\\alpha _{i})_{i=1}^{n}}\n\n satisfying the condition that there exists at most one \n\n\n\nP\n\n\n{\\displaystyle P}\n\n with \n\n\n\ndeg\n\u2061\n(\nP\n)\n\u2a7d\nk\n\u2212\n1\n\n\n{\\displaystyle \\deg(P)\\leqslant k-1}\n\n with \n\n\n\n\u0394\n(\ny\n,\nP\n(\n\n\u03b1\n\ni\n\n\n\n)\n\ni\n\n\n)\n\u2a7d\ne\n\n\n{\\displaystyle \\Delta (y,P(\\alpha _{i})_{i})\\leqslant e}\n\n.\nThe output of the decoder is either the polynomial \n\n\n\nP\n\n\n{\\displaystyle P}\n\n, or in some cases, a failure. This decoder functions in two steps as follows:\nAccording to the algorithm, in the cases where it does not output a failure, it outputs a \n\n\n\nP\n\n\n{\\displaystyle P}\n\n that is the correct and desired polynomial. To prove that, the algorithm always outputs the desired polynomial, we need to prove a few claims we have made while describing the algorithm. Let us go ahead and do so now.\nLet \n\n\n\nE\n\n\n{\\displaystyle E}\n\n be the error-locating polynomial for \n\n\n\nP\n\n\n{\\displaystyle P}\n\n\u00a0:\nNotice that \n\n\n\nE\n\n\n{\\displaystyle E}\n\n has the following properties by definition:\nNow define \n\n\n\nQ\n=\nP\nE\n\n\n{\\displaystyle Q=PE}\n\n and note that:\nWe can now claim that \n\n\n\n\ny\n\ni\n\n\nE\n(\n\n\u03b1\n\ni\n\n\n)\n=\nQ\n(\n\n\u03b1\n\ni\n\n\n)\n\n\n{\\displaystyle y_{i}E(\\alpha _{i})=Q(\\alpha _{i})}\n\n from the first step of the BW algorithm holds. If \n\n\n\nE\n(\n\n\u03b1\n\ni\n\n\n)\n=\n0\n,\n\n\n{\\displaystyle E(\\alpha _{i})=0,}\n\n then \n\n\n\nQ\n(\n\n\u03b1\n\ni\n\n\n)\n=\nP\n(\n\n\u03b1\n\ni\n\n\n)\nE\n(\n\n\u03b1\n\ni\n\n\n)\n=\n\ny\n\ni\n\n\nE\n(\n\n\u03b1\n\ni\n\n\n)\n=\n0\n\n\n{\\displaystyle Q(\\alpha _{i})=P(\\alpha _{i})E(\\alpha _{i})=y_{i}E(\\alpha _{i})=0}\n\n. For \n\n\n\nE\n(\n\n\u03b1\n\ni\n\n\n)\n\u2260\n0\n\n\n{\\displaystyle E(\\alpha _{i})\\neq 0}\n\n we have \n\n\n\nP\n(\n\n\u03b1\n\ni\n\n\n)\n=\n\ny\n\ni\n\n\n\n\n{\\displaystyle P(\\alpha _{i})=y_{i}}\n\n and therefore \n\n\n\nQ\n(\n\n\u03b1\n\ni\n\n\n)\nP\n(\n\n\u03b1\n\ni\n\n\n)\nE\n(\n\n\u03b1\n\ni\n\n\n)\n=\n\ny\n\ni\n\n\nE\n(\n\n\u03b1\n\ni\n\n\n)\n\n\n{\\displaystyle Q(\\alpha _{i})P(\\alpha _{i})E(\\alpha _{i})=y_{i}E(\\alpha _{i})}\n\n just as we claimed.\nThis above claim however just reiterates and proves the fact that there exists a pair of polynomials \n\n\n\nE\n\n\n{\\displaystyle E}\n\n and \n\n\n\nQ\n\n\n{\\displaystyle Q}\n\n such that \n\n\n\nP\n=\n\n\n\nQ\nE\n\n\n\n.\n\n\n{\\displaystyle P={\\tfrac {Q}{E}}.}\n\n It however does not necessarily guarantee the fact that the algorithm we discussed above would indeed output such a pair of polynomials. We therefore move on to look at another claim that helps establish this fact using the above claim and thereby proving the correctness of the algorithm.\nFirst note that\nThen we define:\nNote that \n\n\n\ndeg\n\u2061\n(\nR\n)\n\u2a7d\n2\ne\n+\nk\n\u2212\n1.\n\n\n{\\displaystyle \\deg(R)\\leqslant 2e+k-1.}\n\n From step 1 of the Berlekamp Welch algorithm we also know that \n\n\n\n\ny\n\ni\n\n\n\nE\n\n1\n\n\n(\n\n\u03b1\n\ni\n\n\n)\n=\n\nQ\n\n1\n\n\n(\n\n\u03b1\n\ni\n\n\n)\n\n\n{\\displaystyle y_{i}E_{1}(\\alpha _{i})=Q_{1}(\\alpha _{i})}\n\n and \n\n\n\n\ny\n\ni\n\n\n\nE\n\n2\n\n\n(\n\n\u03b1\n\ni\n\n\n)\n=\n\nQ\n\n2\n\n\n(\n\n\u03b1\n\ni\n\n\n)\n.\n\n\n{\\displaystyle y_{i}E_{2}(\\alpha _{i})=Q_{2}(\\alpha _{i}).}\n\n Now for all \n\n\n\ni\n\u2208\n{\n1\n,\n\u22ef\n,\nn\n}\n\n\n{\\displaystyle i\\in \\{1,\\cdots ,n\\}}\n\n we calculate:\nThus \n\n\n\nR\n\n\n{\\displaystyle R}\n\n has \n\n\n\nn\n\n\n{\\displaystyle n}\n\n roots, on the other hand\nTherefore, \n\n\n\nR\n\n\n{\\displaystyle R}\n\n is the zero polynomial which means that \n\n\n\n\nQ\n\n1\n\n\n\nE\n\n2\n\n\n\n\n{\\displaystyle Q_{1}E_{2}}\n\n and \n\n\n\n\nQ\n\n2\n\n\n\nE\n\n1\n\n\n\n\n{\\displaystyle Q_{2}E_{1}}\n\n are identical. Since \n\n\n\n\nE\n\n1\n\n\n,\n\nE\n\n2\n\n\n\n\n{\\displaystyle E_{1},E_{2}}\n\n are non-zero we can write: \n\n\n\n\n\n\n\nQ\n\n1\n\n\n\nE\n\n1\n\n\n\n\n\n=\n\n\n\n\nQ\n\n2\n\n\n\nE\n\n2\n\n\n\n\n\n\n\n{\\displaystyle {\\tfrac {Q_{1}}{E_{1}}}={\\tfrac {Q_{2}}{E_{2}}}}\n\n as per our initial claim.\nThus based on the above claims, we can safely state that the output of the Berlekamp Welch algorithm, when outputting the polynomial \n\n\n\nP\n(\nX\n)\n\n\n{\\displaystyle P(X)}\n\n is correct.\nWe can now claim that the algorithm can be implemented such that it has a running time of \n\n\n\nO\n(\n\nn\n\n3\n\n\n)\n\n\n{\\displaystyle O(n^{3})}\n\n. This can be proved as follows: In Step 1 of the algorithm, the polynomials \n\n\n\nQ\n\n\n{\\displaystyle Q}\n\n and \n\n\n\nE\n\n\n{\\displaystyle E}\n\n have \n\n\n\ne\n+\nk\n\n\n{\\displaystyle e+k}\n\n and \n\n\n\ne\n+\n1\n\n\n{\\displaystyle e+1}\n\n unknown values respectively and the constraints \n\n\n\n\ny\n\ni\n\n\nE\n(\n\n\u03b1\n\ni\n\n\n)\n=\nQ\n(\n\n\u03b1\n\ni\n\n\n)\n\n\n{\\displaystyle y_{i}E(\\alpha _{i})=Q(\\alpha _{i})}\n\n for all \n\n\n\n1\n\u2a7d\ni\n\u2a7d\nn\n\n\n{\\displaystyle 1\\leqslant i\\leqslant n}\n\n acts as a linear equation with these unknowns. We therefore get a system of \n\n\n\nn\n\n\n{\\displaystyle n}\n\n linear equations in \n\n\n\n2\ne\n+\nk\n+\n1\n<\nn\n+\n2\n\n\n{\\displaystyle 2e+k+1<n+2}\n\n unknowns. Using our first claim, this system of equations has a solution since \n\n\n\ndeg\n\u2061\n(\nE\n)\n=\ne\n.\n\n\n{\\displaystyle \\deg(E)=e.}\n\n This can be solved in \n\n\n\nO\n(\n\nn\n\n3\n\n\n)\n\n\n{\\displaystyle O(n^{3})}\n\n time, by say Gaussian elimination. Finally, we can note that Step 2 of the algorithm can also be implemented in time \n\n\n\nO\n(\n\nn\n\n3\n\n\n)\n\n\n{\\displaystyle O(n^{3})}\n\n by \"long division\" method. Hence we can state that the Berlekamp Welch algorithm can be used to uniquely decode any \n\n\n\n[\nn\n,\nk\n\n]\n\nq\n\n\n\n\n{\\displaystyle [n,k]_{q}}\n\n Reed\u2013Solomon code in \n\n\n\nO\n(\n\nn\n\n3\n\n\n)\n\n\n{\\displaystyle O(n^{3})}\n\n time for a maximum of \n\n\n\n\n\n\n1\n2\n\n\n\n(\nn\n\u2212\nk\n+\n1\n)\n\n\n{\\displaystyle {\\tfrac {1}{2}}(n-k+1)}\n\n errors.\nConsider a simple example where a redundant set of points are used to represent the line \n\n\n\ny\n=\n5\n\u2212\nx\n\n\n{\\displaystyle y=5-x}\n\n, and one of the points is incorrect. The points that the algorithm gets as an input are \n\n\n\n(\n1\n,\n4\n)\n,\n(\n2\n,\n3\n)\n,\n(\n3\n,\n4\n)\n,\n(\n4\n,\n1\n)\n\n\n{\\displaystyle (1,4),(2,3),(3,4),(4,1)}\n\n, where \n\n\n\n(\n3\n,\n4\n)\n\n\n{\\displaystyle (3,4)}\n\n is the defective point. The algorithm must solve the following system of equations:\nGiven a solution pair \n\n\n\n(\nQ\n,\nE\n)\n\n\n{\\displaystyle (Q,E)}\n\n to this system of equations, it is evident that at any of the points \n\n\n\nx\n=\n1\n,\n2\n,\n3\n,\n4\n\n\n{\\displaystyle x=1,2,3,4}\n\n one of the following must be true:\nSince \n\n\n\nE\n\n\n{\\displaystyle E}\n\n is defined as only having a degree of one, the former can only be true in one point. Therefore, \n\n\n\nP\n(\n\n\u03b1\n\ni\n\n\n)\n=\n\ny\n\ni\n\n\n\n\n{\\displaystyle P(\\alpha _{i})=y_{i}}\n\n at the three other points.\nLetting \n\n\n\nE\n(\nx\n)\n=\nx\n+\n\ne\n\n0\n\n\n\n\n{\\displaystyle E(x)=x+e_{0}}\n\n and \n\n\n\nQ\n=\n\nq\n\n0\n\n\n+\n\nq\n\n1\n\n\nx\n+\n\nq\n\n2\n\n\n\nx\n\n2\n\n\n\n\n{\\displaystyle Q=q_{0}+q_{1}x+q_{2}x^{2}}\n\n we can rewrite the system:\nThis system can be solved through Gaussian elimination, and gives the values:\nThus:\n\n\n\n\n5\n\u2212\nx\n\n\n{\\displaystyle 5-x}\n\n fits three of the four points given, so it is the most likely to be the original polynomial.", 
    "dbpedia_url": "http://dbpedia.org/resource/Berlekamp\u2013Welch_algorithm", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Berlekamp\u2013Welch_algorithm\n"
}