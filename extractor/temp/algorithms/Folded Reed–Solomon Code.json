{
    "about": "In coding theory, folded Reed\u2013Solomon codes are like Reed\u2013Solomon codes, which are obtained by mapping \n\n\n\nm\n\n\n{\\displaystyle m}\n\n Reed\u2013Solomon codewords over a larger alphabet by careful bundling of codeword symbols.", 
    "name": "Folded Reed\u2013Solomon Code", 
    "classification": "Error Detection And Correction", 
    "full_text": "In coding theory, folded Reed\u2013Solomon codes are like Reed\u2013Solomon codes, which are obtained by mapping \n\n\n\nm\n\n\n{\\displaystyle m}\n\n Reed\u2013Solomon codewords over a larger alphabet by careful bundling of codeword symbols.\nFolded Reed\u2013Solomon codes are also a special case of Parvaresh\u2013Vardy codes.\nUsing optimal parameters one can decode with a rate of R, and achieve a decoding radius of 1\u00a0\u2212\u00a0R.\nThe term \"folded Reed\u2013Solomon codes\" was coined in a paper by V.Y. Krachkovsky with an algorithm that presented Reed\u2013Solomon codes with many random \"phased burst\" errors [1]. The list-decoding algorithm for folded RS codes corrects beyond the \n\n\n\n1\n\u2212\n\n\nR\n\n\n\n\n{\\displaystyle 1-{\\sqrt {R}}}\n\n bound for Reed\u2013Solomon codes achieved by the Guruswami\u2013Sudan algorithm for such phased burst errors.\n\n\nOne of the ongoing challenges in Coding Theory is to have error correcting codes achieve an optimal trade-off between (Coding) Rate and Error-Correction Radius. Though this may not be possible to achieve practically (due to Noisy Channel Coding Theory issues), quasi optimal tradeoffs can be achieved theoretically.\nPrior to Folded Reed\u2013Solomon codes being devised, the best Error-Correction Radius achieved was \n\n\n\n1\n\u2212\n\n\nR\n\n\n\n\n{\\displaystyle 1-{\\sqrt {R}}}\n\n, by Reed\u2013Solomon codes for all rates \n\n\n\nR\n\n\n{\\displaystyle R}\n\n.\nAn improvement upon this \n\n\n\n1\n\u2212\n\n\nR\n\n\n\n\n{\\displaystyle 1-{\\sqrt {R}}}\n\n bound was achieved by Parvaresh and Vardy for rates \n\n\n\nR\n<\n\n\n\n1\n16\n\n\n\n.\n\n\n{\\displaystyle R<{\\tfrac {1}{16}}.}\n\n\nFor \n\n\n\nR\n\u2192\n0\n\n\n{\\displaystyle R\\to 0}\n\n the Parvaresh\u2013Vardy algorithm can decode a fraction \n\n\n\n1\n\u2212\nO\n(\nR\nlog\n\u2061\n(\n1\n\n/\n\nR\n)\n)\n\n\n{\\displaystyle 1-O(R\\log(1/R))}\n\n of errors.\nFolded Reed\u2013Solomon Codes improve on these previous constructions, and can be list decoded in polynomial time for a fraction \n\n\n\n(\n1\n\u2212\nR\n\u2212\n\u03b5\n)\n\n\n{\\displaystyle (1-R-\\varepsilon )}\n\n of errors for any constant \n\n\n\n\u03b5\n>\n0\n\n\n{\\displaystyle \\varepsilon >0}\n\n.\nConsider a Reed\u2013Solomon \n\n\n\n[\nn\n=\nq\n\u2212\n1\n,\nk\n\n]\n\nq\n\n\n\n\n{\\displaystyle [n=q-1,k]_{q}}\n\n code of length \n\n\n\nn\n\n\n{\\displaystyle n}\n\n and dimension \n\n\n\nk\n\n\n{\\displaystyle k}\n\n and a folding parameter \n\n\n\nm\n\u2265\n1\n\n\n{\\displaystyle m\\geq 1}\n\n. Assume that \n\n\n\nm\n\n\n{\\displaystyle m}\n\n divides \n\n\n\nn\n\n\n{\\displaystyle n}\n\n.\nMapping for Reed\u2013Solomon codes like this:\nwhere \n\n\n\n\u03b3\n\u2208\n\n\nF\n\n\nq\n\n\n\n\n{\\displaystyle \\gamma \\in \\mathbb {F} _{q}}\n\n is a primitive element in\nThe \n\n\n\nm\n\n\n{\\displaystyle m}\n\n folded version of Reed Solomon code \n\n\n\nC\n\n\n{\\displaystyle C}\n\n, denoted \n\n\n\nF\nR\n\nS\n\n\nF\n\n,\n\u03b3\n,\nm\n,\nk\n\n\n\n\n{\\displaystyle FRS_{\\mathbb {F} ,\\gamma ,m,k}}\n\n is a code of block length \n\n\n\nN\n=\nn\n\n/\n\nm\n\n\n{\\displaystyle N=n/m}\n\n over \n\n\n\n\n\nF\n\n\nm\n\n\n\n\n{\\displaystyle \\mathbb {F} ^{m}}\n\n. \n\n\n\nF\nR\n\nS\n\n\nF\n\n,\n\u03b3\n,\nm\n,\nk\n\n\n\n\n{\\displaystyle FRS_{\\mathbb {F} ,\\gamma ,m,k}}\n\n are just \n\n\n\n[\nq\n\u2212\n1\n,\nk\n]\n\n\n{\\displaystyle [q-1,k]}\n\n Reed Solomon codes with \n\n\n\nm\n\n\n{\\displaystyle m}\n\n consecutive symbols from RS codewords grouped together.\nThe above definition is made more clear by means of the diagram with \n\n\n\nm\n=\n3\n\n\n{\\displaystyle m=3}\n\n, where \n\n\n\nm\n\n\n{\\displaystyle m}\n\n is the folding parameter.\nThe message is denoted by \n\n\n\nf\n(\nX\n)\n\n\n{\\displaystyle f(X)}\n\n, which when encoded using Reed\u2013Solomon encoding, consists of values of \n\n\n\nf\n\n\n{\\displaystyle f}\n\n at \n\n\n\n\nx\n\n0\n\n\n,\n\nx\n\n1\n\n\n,\n\nx\n\n2\n\n\n,\n\u2026\n,\n\nx\n\nn\n\u2212\n1\n\n\n\n\n{\\displaystyle x_{0},x_{1},x_{2},\\ldots ,x_{n-1}}\n\n, where \n\n\n\n\nx\n\ni\n\n\n=\n\n\u03b3\n\ni\n\n\n\n\n{\\displaystyle x_{i}=\\gamma ^{i}}\n\n.\nThen bundling is performed in groups of 3 elements, to give a codeword of length \n\n\n\nn\n\n/\n\n3\n\n\n{\\displaystyle n/3}\n\n over the alphabet \n\n\n\n\n\nF\n\n\nq\n\n\n3\n\n\n\n\n{\\displaystyle \\mathbb {F} _{q}^{3}}\n\n.\nSomething to be observed here is that the folding operation demonstrated does not change the rate \n\n\n\nR\n\n\n{\\displaystyle R}\n\n of the original Reed\u2013Solomon code.\nTo prove this, consider a linear \n\n\n\n[\nn\n,\nk\n,\nd\n\n]\n\nq\n\n\n\n\n{\\displaystyle [n,k,d]_{q}}\n\n code, of length \n\n\n\nn\n\n\n{\\displaystyle n}\n\n, dimension \n\n\n\nk\n\n\n{\\displaystyle k}\n\n and distance \n\n\n\nd\n\n\n{\\displaystyle d}\n\n. The \n\n\n\nm\n\n\n{\\displaystyle m}\n\n folding operation will make it a \n\n\n\n\n\n[\n\n\n\nn\nm\n\n\n\n,\n\n\n\nk\nm\n\n\n\n,\n\n\n\nd\nm\n\n\n\n]\n\n\n\nq\n\nm\n\n\n\n\n\n\n{\\displaystyle \\left[{\\tfrac {n}{m}},{\\tfrac {k}{m}},{\\tfrac {d}{m}}\\right]_{q^{m}}}\n\n code. By this, the rate \n\n\n\nR\n=\n\n\n\nn\nk\n\n\n\n\n\n{\\displaystyle R={\\tfrac {n}{k}}}\n\n will be the same.\nAccording to the asymptotic version of the singleton bound, it is known that the relative distance \n\n\n\n\u03b4\n\n\n{\\displaystyle \\delta }\n\n, of a code must satisfy \n\n\n\nR\n\u2a7d\n1\n\u2212\n\u03b4\n+\no\n(\n1\n)\n\n\n{\\displaystyle R\\leqslant 1-\\delta +o(1)}\n\n where \n\n\n\nR\n\n\n{\\displaystyle R}\n\nis the rate of the code. As proved earlier, since the rate \n\n\n\nR\n\n\n{\\displaystyle R}\n\n is maintained, the relative distance \n\n\n\n\u03b4\n\u2a7e\n1\n\u2212\nR\n\n\n{\\displaystyle \\delta \\geqslant 1-R}\n\n also meets the Singleton bound.\nFolded Reed\u2013Solomon codes are basically the same as Reed Solomon codes, just viewed over a larger alphabet. To show how this might help, consider a folded Reed\u2013Solomon code with \n\n\n\nm\n=\n3\n\n\n{\\displaystyle m=3}\n\n. Decoding a Reed\u2013Solomon code and folded Reed\u2013Solomon code from the same fraction of errors \n\n\n\n\u03c1\n\n\n{\\displaystyle \\rho }\n\n are tasks of almost of the same computational intensity: one can unfold the received word of the folded Reed\u2013Solomon code, treat it as an received word of the original Reed\u2013Solomon code, and run the Reed\u2013Solomon list decoding algorithm on it. Obviously, this list will contain all the folded Reed\u2013Solomon codewords within distance \n\n\n\n\u03c1\n\n\n{\\displaystyle \\rho }\n\n of the received word, along with some extras, which we can expurgate.\nAlso, decoding a folded Reed\u2013Solomon code is an easier task. Suppose we want to correct a third of errors. The decoding algorithm chosen must correct an error pattern that corrects every third symbol in the Reed\u2013Solomon encoding. But after folding, this error pattern will corrupt all symbols over \n\n\n\n\n\nF\n\n\nq\n\n\n3\n\n\n\n\n{\\displaystyle \\mathbb {F} _{q}^{3}}\n\n and will eliminate the need for error correction. This propagation of errors is indicated by the blue color in the graphical description. This proves that the for a fixed fraction of errors \n\n\n\n\u03c1\n,\n\n\n{\\displaystyle \\rho ,}\n\n the folding operation reduces the channel's flexibility to distribute errors, which in turn leads to a reduction in the number of error patterns that need to be corrected.\nWe can relate Folded Reed Solomon codes with Parvaresh Vardy codes which encodes a polynomial \n\n\n\nf\n\n\n{\\displaystyle f}\n\n of degree \n\n\n\nk\n\n\n{\\displaystyle k}\n\n with polynomials \n\n\n\n\nf\n\n0\n\n\n=\nf\n,\n\nf\n\n1\n\n\n,\n\u2026\n,\n\nf\n\ns\n\u2212\n1\n\n\n(\ns\n\u2a7e\n2\n)\n\n\n{\\displaystyle f_{0}=f,f_{1},\\ldots ,f_{s-1}(s\\geqslant 2)}\n\n where \n\n\n\n\nf\n\ni\n\n\n(\nX\n)\n=\n\nf\n\ni\n\u2212\n1\n\n\n(\nX\n\n)\n\nd\n\n\n\nmod\n\n\nE\n(\nX\n)\n\n\n{\\displaystyle f_{i}(X)=f_{i-1}(X)^{d}\\mod E(X)}\n\n where \n\n\n\nE\n(\nX\n)\n\n\n{\\displaystyle E(X)}\n\n is an irreducible polynomial. While choosing irreducible polynomial \n\n\n\nE\n(\nX\n)\n=\n\nX\n\nq\n\n\n\u2212\n\u03b3\n\n\n{\\displaystyle E(X)=X^{q}-\\gamma }\n\n and parameter \n\n\n\nd\n\n\n{\\displaystyle d}\n\n we should check if every polynomial \n\n\n\nf\n\n\n{\\displaystyle f}\n\n of degree at most \n\n\n\nk\n\n\n{\\displaystyle k}\n\n satisfies \n\n\n\nf\n(\n\u03b3\nX\n)\n=\nf\n(\nX\n\n)\n\nd\n\n\n\nmod\n\n\nE\n(\nX\n)\n\n\n{\\displaystyle f(\\gamma X)=f(X)^{d}\\mod E(X)}\n\n since \n\n\n\nf\n(\n\u03b3\nX\n)\n\n\n{\\displaystyle f(\\gamma X)}\n\n is just the shifted counterpart of \n\n\n\nf\n(\nX\n)\n\n\n{\\displaystyle f(X)}\n\n where \n\n\n\n\u03b3\n\n\n{\\displaystyle \\gamma }\n\n is the primitive element in \n\n\n\n\n\nF\n\n\nq\n\n\n.\n\n\n{\\displaystyle \\mathbb {F} _{q}.}\n\n Thus folded RS code with bundling together code symbols is PV code of order \n\n\n\ns\n=\nm\n\n\n{\\displaystyle s=m}\n\n for the set of evaluation points\nIf we compare the folded RS code to a PV code of order 2 for the set of evaluation points\nwe can see that in PV encoding of \n\n\n\nf\n\n\n{\\displaystyle f}\n\n, for every \n\n\n\n0\n\u2264\ni\n\u2264\nn\n\n/\n\nm\n\u2212\n1\n\n\n{\\displaystyle 0\\leq i\\leq n/m-1}\n\n and every \n\n\n\n0\n<\nj\n<\nm\n\u2212\n1\n,\nf\n(\n\n\u03b3\n\nm\ni\n+\nj\n\n\n)\n\n\n{\\displaystyle 0<j<m-1,f(\\gamma ^{mi+j})}\n\n appears at \n\n\n\nf\n(\n\n\u03b3\n\nm\ni\n+\nj\n\n\n)\n\n\n{\\displaystyle f(\\gamma ^{mi+j})}\n\n and \n\n\n\n\nf\n\n1\n\n\n(\n\n\u03b3\n\n\u2212\n1\n\n\n\n\u03b3\n\nm\ni\n+\nj\n\n\n)\n\n\n{\\displaystyle f_{1}(\\gamma ^{-1}\\gamma ^{mi+j})}\n\n,\nunlike in the folded FRS encoding in which it appears only once. Thus, the PV and folded RS codes have same information but only the rate of FRS is bigger by a factor of \n\n\n\n2\n(\nm\n\u2212\n1\n)\n\n/\n\nm\n\n\n{\\displaystyle 2(m-1)/m}\n\n and hence the list decoding radius trade-off is better for folded RS code by just using the list decodability of the PV codes. The plus point is in choosing FRS code in a way that they are compressed forms of suitable PV code with similar error correction performance with better rate than corresponding PV code. One can use this idea to construct a folded RS codes of rate \n\n\n\nR\n\n\n{\\displaystyle R}\n\n that are list decodable up to radius approximately \n\n\n\n1\n\u2212\n\nR\n\ns\n\n/\n\n[\ns\n+\n1\n]\n\n\n\n\n{\\displaystyle 1-R^{s/[s+1]}}\n\n for \n\n\n\ns\n\u2265\n1\n\n\n{\\displaystyle s\\geq 1}\n\n. [2]\nA list decoding algorithm which runs in quadratic time to decode FRS code up to radius \n\n\n\n1\n\u2212\nR\n\u2212\n\u03b5\n\n\n{\\displaystyle 1-R-\\varepsilon }\n\n is presented by Guruswami. The algorithm essentially has three steps namely the interpolation step in which welch berlekamp style interpolation is used to interpolate the non-zero polynomial\nafter which all the polynomials \n\n\n\nf\n\u2208\n\n\nF\n\n\nq\n\n\n[\nX\n]\n\n\n{\\displaystyle f\\in \\mathbb {F} _{q}[X]}\n\n with degree \n\n\n\nk\n\u2212\n1\n\n\n{\\displaystyle k-1}\n\n satisfying the equation derived in interpolation are found. In the third step the actual list of close-by codewords are known by pruning the solution subspace which takes \n\n\n\n\nq\n\ns\n\n\n\n\n{\\displaystyle q^{s}}\n\ntime.\nGuruswami presents a \n\n\n\n\nn\n\n\u03a9\n(\n1\n\n/\n\n\n\u03b5\n\n2\n\n\n)\n\n\n\n\n{\\displaystyle n^{\\Omega (1/\\varepsilon ^{2})}}\n\n time list decoding algorithm based on linear-algebra, which can decode folded Reed\u2013Solomon code up to radius \n\n\n\n1\n\u2212\nR\n\u2212\n\u03b5\n\n\n{\\displaystyle 1-R-\\varepsilon }\n\n with a list-size of \n\n\n\n\n\nn\n\nO\n(\n1\n\n/\n\n\n\u03b5\n\n2\n\n\n)\n\n\n\n\n\n{\\displaystyle {n^{O(1/\\varepsilon ^{2})}}}\n\n. There are three steps in this algorithm: Interpolation Step, Root Finding Step and Prune Step. In the Interpolation step it will try to find the candidate message polynomial \n\n\n\nf\n(\nx\n)\n\n\n{\\displaystyle f(x)}\n\n by solving a linear system. In the Root Finding step, it will try to find the solution subspace by solving another linear system. The last step will try to prune the solution subspace gained in the second step. We will introduce each step in details in the following.\nIt is a Welch\u2013Berlekamp-style interpolation (because it can be viewed as the higher-dimensional generalization of the Welch\u2013Berlekamp algorithm). Suppose we received a codeword \n\n\n\ny\n\n\n{\\displaystyle y}\n\n of the \n\n\n\nm\n\n\n{\\displaystyle m}\n\n-folded Reed\u2013Solomon code as shown below\nWe interpolate the nonzero polynomial\nby using a carefully chosen degree parameter \n\n\n\nD\n\n\n{\\displaystyle D}\n\n.\nSo the interpolation requirements will be\nThen the number of monomials in \n\n\n\nQ\n(\nX\n,\n\nY\n\n1\n\n\n,\n\u2026\n,\n\nY\n\ns\n\n\n)\n\n\n{\\displaystyle Q(X,Y_{1},\\ldots ,Y_{s})}\n\n is\nBecause the number of monomials in \n\n\n\nQ\n(\nX\n,\n\nY\n\n1\n\n\n,\n\u2026\n,\n\nY\n\ns\n\n\n)\n\n\n{\\displaystyle Q(X,Y_{1},\\ldots ,Y_{s})}\n\n is greater than the number of interpolation conditions. We have below lemma\nThis lemma shows us that the interpolation step can be done in near-linear time.\nFor now, we have talked about everything we need for the multivariate polynomial \n\n\n\nQ\n(\nX\n,\n\nY\n\n1\n\n\n,\n\u2026\n,\n\nY\n\ns\n\n\n)\n\n\n{\\displaystyle Q(X,Y_{1},\\ldots ,Y_{s})}\n\n. The remaining task is to focus on the message polynomials \n\n\n\nf\n(\nX\n)\n\n\n{\\displaystyle f(X)}\n\n.\nHere \"agree\" means that all the \n\n\n\nm\n\n\n{\\displaystyle m}\n\n values in a column should match the corresponding values in codeword \n\n\n\ny\n\n\n{\\displaystyle y}\n\n.\nThis lemma shows us that any such polynomial \n\n\n\nQ\n(\nX\n,\n\nY\n\n1\n\n\n,\n\u2026\n,\n\nY\n\ns\n\n\n)\n\n\n{\\displaystyle Q(X,Y_{1},\\ldots ,Y_{s})}\n\n presents an algebraic condition that must be satisfied for those message polynomials \n\n\n\nf\n(\nx\n)\n\n\n{\\displaystyle f(x)}\n\n that we are interested in list decoding.\nCombining Lemma 2 and parameter \n\n\n\nD\n\n\n{\\displaystyle D}\n\n, we have\nFurther we can get the decoding bound\nWe notice that the fractional agreement is\nDuring this step, our task focus on how to find all polynomials \n\n\n\nf\n\u2208\n\n\n\nF\n\n\nq\n\n\n[\nX\n]\n\n\n\n{\\displaystyle f\\in {\\mathbb {F} _{q}[X]}}\n\n with degree no more than \n\n\n\nk\n\u2212\n1\n\n\n{\\displaystyle k-1}\n\n and satisfy the equation we get from Step 1, namely\nSince the above equation forms a linear system equations over \n\n\n\n\n\nF\n\n\nq\n\n\n\n\n{\\displaystyle \\mathbb {F} _{q}}\n\n in the coefficients \n\n\n\n\nf\n\n0\n\n\n,\n\nf\n\n1\n\n\n,\n\u2026\n,\n\nf\n\nk\n\u2212\n1\n\n\n\n\n{\\displaystyle f_{0},f_{1},\\ldots ,f_{k-1}}\n\n of the polynomial\nthe solutions to the above equation is an affine subspace of \n\n\n\n\n\nF\n\n\nq\n\n\nk\n\n\n\n\n{\\displaystyle \\mathbb {F} _{q}^{k}}\n\n. This fact is the key point that gives rise to an efficient algorithm - we can solve the linear system.\nIt is natural to ask how large is the dimension of the solution? Is there any upper bound on the dimension? Having an upper bound is very important in constructing an efficient list decoding algorithm because one can simply output all the codewords for any given decoding problem.\nActually it indeed has an upper bound as below lemma argues.\nThis lemma shows us the upper bound of the dimension for the solution space.\nFinally, based on the above analysis, we have below theorem\nWhen \n\n\n\ns\n=\nm\n=\n1\n\n\n{\\displaystyle s=m=1}\n\n, we notice that this reduces to a unique decoding algorithm with up to a fraction \n\n\n\n(\n1\n\u2212\nR\n)\n\n/\n\n2\n\n\n{\\displaystyle (1-R)/2}\n\n of errors. In other words, we can treat unique decoding algorithm as a specialty of list decoding algorithm. The quantity is about \n\n\n\n\nn\n\nO\n(\n1\n\n/\n\n\u03b5\n)\n\n\n\n\n{\\displaystyle n^{O(1/\\varepsilon )}}\n\n for the parameter choices that achieve a list decoding radius of \n\n\n\n1\n\u2212\nR\n\u2212\n\u03b5\n\n\n{\\displaystyle 1-R-\\varepsilon }\n\n.\nTheorem 1 tells us exactly how large the error radius would be.\nNow we finally get the solution subspace. However, there is still one problem standing. The list size in the worst case is \n\n\n\n\nn\n\n\u03a9\n(\n1\n\n/\n\n\u03b5\n)\n\n\n\n\n{\\displaystyle n^{\\Omega (1/\\varepsilon )}}\n\n. But the actual list of close-by codewords is only a small set within that subspace. So we need some process to prune the subspace to narrow it down. This prune process takes \n\n\n\n\nq\n\ns\n\n\n\n\n{\\displaystyle q^{s}}\n\n time in the worst case. Unfortunately it is not known how to improve the running time because we do not know how to improve the bound of the list size for folded Reed-Solomon code.\nThings get better if we change the code by carefully choosing a subset of all possible degree \n\n\n\nk\n\u2212\n1\n\n\n{\\displaystyle k-1}\n\n polynomials as messages, the list size shows to be much smaller while only losing a little bit in the rate. We will talk about this briefly in next step.\nBy converting the problem of decoding a folded Reed\u2013Solomon code into two linear systems, one linear system that is used for the interpolation step and another linear system to find the candidate solution subspace, the complexity of the decoding problem is successfully reduced to quadratic. However, in the worst case, the bound of list size of the output is pretty bad.\nIt was mentioned in Step 2 that if one carefully chooses only a subset of all possible degree \n\n\n\nk\n\u2212\n1\n\n\n{\\displaystyle k-1}\n\n polynomials as messages, the list size can be much reduced. Here we will expand our discussion.\nTo achieve this goal, the idea is to limit the coefficient vector \n\n\n\n(\n\nf\n\n0\n\n\n,\n\nf\n\n1\n\n\n,\n\u2026\n,\n\nf\n\nk\n\u2212\n1\n\n\n)\n\n\n{\\displaystyle (f_{0},f_{1},\\ldots ,f_{k-1})}\n\n to a special subset \n\n\n\n\u03bd\n\u2286\n\n\nF\n\n\nq\n\n\nk\n\n\n\n\n{\\displaystyle \\nu \\subseteq \\mathbb {F} _{q}^{k}}\n\n, which satisfies below two conditions:\nThis is to make sure that the rate will be at most reduced by factor of \n\n\n\n(\n1\n\u2212\n\u03b5\n)\n\n\n{\\displaystyle (1-\\varepsilon )}\n\n.\nThe bound for the list size at worst case is \n\n\n\n\nn\n\n\u03a9\n(\n1\n\n/\n\n\u03b5\n)\n\n\n\n\n{\\displaystyle n^{\\Omega (1/\\varepsilon )}}\n\n, and it can be reduced to a relative small bound \n\n\n\nO\n(\n1\n\n/\n\n\n\u03b5\n\n2\n\n\n)\n\n\n{\\displaystyle O(1/\\varepsilon ^{2})}\n\n by using subspace-evasive subsets.\nDuring this step, as it has to check each element of the solution subspace that we get from Step 2, it takes \n\n\n\n\nq\n\ns\n\n\n\n\n{\\displaystyle q^{s}}\n\n time in the worst case (\n\n\n\ns\n\n\n{\\displaystyle s}\n\n is the dimension of the solution subspace).\nDvir and Lovett improved the result based on the work of Guruswami, which can reduce the list size to a constant.\nHere is only presented the idea that is used to prune the solution subspace. For the details of the prune process, please refer to papers by Guruswami, Dvir and Lovett, which are listed in the reference.\nIf we don't consider the Step 3, this algorithm can run in quadratic time. A summary for this algorithm is listed below.", 
    "dbpedia_url": "http://dbpedia.org/resource/Folded_Reed\u2013Solomon_code", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Folded_Reed\u2013Solomon_code\n"
}