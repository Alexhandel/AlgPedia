{
    "about": "The Jenkins\u2013Traub algorithm for polynomial zeros is a fast globally convergent iterative method published in 1970 by Michael A. Jenkins and Joseph F. Traub. They gave two variants, one for general polynomials with complex coefficients, commonly known as the \"CPOLY\" algorithm, and a more complicated variant for the special case of polynomials with real coefficients, commonly known as the \"RPOLY\" algorithm. The latter is \"practically a standard in black-box polynomial root-finders\".[1]", 
    "name": "Jenkins\u2013Traub Algorithm", 
    "classification": "Numerical Analysis", 
    "full_text": "The Jenkins\u2013Traub algorithm for polynomial zeros is a fast globally convergent iterative method published in 1970 by Michael A. Jenkins and Joseph F. Traub. They gave two variants, one for general polynomials with complex coefficients, commonly known as the \"CPOLY\" algorithm, and a more complicated variant for the special case of polynomials with real coefficients, commonly known as the \"RPOLY\" algorithm. The latter is \"practically a standard in black-box polynomial root-finders\".[1]\nThis article describes the complex variant. Given a polynomial P,\nwith complex coefficients it computes approximations to the n zeros \n\n\n\n\n\u03b1\n\n1\n\n\n,\n\n\u03b1\n\n2\n\n\n,\n\u2026\n,\n\n\u03b1\n\nn\n\n\n\n\n{\\displaystyle \\alpha _{1},\\alpha _{2},\\dots ,\\alpha _{n}}\n\n of P(z), one at a time in roughly increasing order of magnitude. After each root is computed, its linear factor is removed from the polynomial. Using this deflation guarantees that each root is computed only once and that all roots are found.\nThe real variant follows the same pattern, but computes two roots at a time, either two real roots or a pair of conjugate complex roots. By avoiding complex arithmetic, the real variant can be faster (by a factor of 4) than the complex variant. The Jenkins\u2013Traub algorithm has stimulated considerable research on theory and software for methods of this type.\n\n\nThe Jenkins\u2013Traub algorithm calculates all of the roots of a polynomial with complex coefficients. The algorithm starts by checking the polynomial for the occurrence of very large or very small roots. If necessary, the coefficients are rescaled by a rescaling of the variable. In the algorithm proper, roots are found one by one and generally in increasing size. After each root is found, the polynomial is deflated by dividing off the corresponding linear factor. Indeed, the factorization of the polynomial into the linear factor and the remaining deflated polynomial is already a result of the root-finding procedure. The root-finding procedure has three stages that correspond to different variants of the inverse power iteration. See Jenkins and Traub.[2] A description can also be found in Ralston and Rabinowitz[3] p.\u00a0383. The algorithm is similar in spirit to the two-stage algorithm studied by Traub.[4]\nStarting with the current polynomial P(X) of degree n, the smallest root of P(x) is computed. To that end, a sequence of so-called H polynomials is constructed. These polynomials are all of degree n\u00a0\u2212\u00a01 and are supposed to converge to the factor of P(X) containing all the remaining roots. The sequence of H polynomials occurs in two variants, an unnormalized variant that allows easy theoretical insights and a normalized variant of \n\n\n\n\n\n\nH\n\u00af\n\n\n\n\n\n{\\displaystyle {\\bar {H}}}\n\n polynomials that keeps the coefficients in a numerically sensible range.\nThe construction of the H polynomials \n\n\n\n\n\n(\n\nH\n\n(\n\u03bb\n)\n\n\n(\nz\n)\n)\n\n\n\u03bb\n=\n0\n,\n1\n,\n2\n,\n\u2026\n\n\n\n\n{\\displaystyle \\left(H^{(\\lambda )}(z)\\right)_{\\lambda =0,1,2,\\dots }}\n\n depends on a sequence of complex numbers \n\n\n\n(\n\ns\n\n\u03bb\n\n\n\n)\n\n\u03bb\n=\n0\n,\n1\n,\n2\n,\n\u2026\n\n\n\n\n{\\displaystyle (s_{\\lambda })_{\\lambda =0,1,2,\\dots }}\n\n called shifts. These shifts themselves depend, at least in the third stage, on the previous H polynomials. The H polynomials are defined as the solution to the implicit recursion\nA direct solution to this implicit equation is\nwhere the polynomial division is exact.\nAlgorithmically, one would use for instance the Horner scheme or Ruffini rule to evaluate the polynomials at \n\n\n\n\ns\n\n\u03bb\n\n\n\n\n{\\displaystyle s_{\\lambda }}\n\n and obtain the quotients at the same time. With the resulting quotients p(X) and h(X) as intermediate results the next H polynomial is obtained as\nSince the highest degree coefficient is obtained from P(X), the leading coefficient of \n\n\n\n\nH\n\n(\n\u03bb\n+\n1\n)\n\n\n(\nX\n)\n\n\n{\\displaystyle H^{(\\lambda +1)}(X)}\n\n is \n\n\n\n\u2212\n\n\n\n\n\nH\n\n(\n\u03bb\n)\n\n\n(\n\ns\n\n\u03bb\n\n\n)\n\n\nP\n(\n\ns\n\n\u03bb\n\n\n)\n\n\n\n\n\n\n{\\displaystyle -{\\tfrac {H^{(\\lambda )}(s_{\\lambda })}{P(s_{\\lambda })}}}\n\n. If this is divided out the normalized H polynomial is\nFor \n\n\n\n\u03bb\n=\n0\n,\n1\n,\n\u2026\n,\nM\n\u2212\n1\n\n\n{\\displaystyle \\lambda =0,1,\\dots ,M-1}\n\n set \n\n\n\n\ns\n\n\u03bb\n\n\n=\n0\n\n\n{\\displaystyle s_{\\lambda }=0}\n\n. Usually M=5 is chosen for polynomials of moderate degrees up to n\u00a0=\u00a050. This stage is not necessary from theoretical considerations alone, but is useful in practice. It emphasizes in the H polynomials the cofactor (of the linear factor) of the smallest root.\nThe shift for this stage is determined as some point close to the smallest root of the polynomial. It is quasi-randomly located on the circle with the inner root radius, which in turn is estimated as the positive solution of the equation\nSince the left side is a convex function and increases monotonically from zero to infinity, this equation is easy to solve, for instance by Newton's method.\nNow choose \n\n\n\ns\n=\nR\n\u22c5\nexp\n\u2061\n(\ni\n\n\n\u03d5\n\nrandom\n\n\n)\n\n\n{\\displaystyle s=R\\cdot \\exp(i\\,\\phi _{\\text{random}})}\n\n on the circle of this radius. The sequence of polynomials \n\n\n\n\nH\n\n(\n\u03bb\n+\n1\n)\n\n\n(\nz\n)\n\n\n{\\displaystyle H^{(\\lambda +1)}(z)}\n\n, \n\n\n\n\u03bb\n=\nM\n,\nM\n+\n1\n,\n\u2026\n,\nL\n\u2212\n1\n\n\n{\\displaystyle \\lambda =M,M+1,\\dots ,L-1}\n\n, is generated with the fixed shift value \n\n\n\n\ns\n\n\u03bb\n\n\n=\ns\n\n\n{\\displaystyle s_{\\lambda }=s}\n\n. During this iteration, the current approximation for the root\nis traced. The second stage is finished successfully if the conditions\nare simultaneously met. If there was no success after some number of iterations, a different random point on the circle is tried. Typically one uses a number of 9 iterations for polynomials of moderate degree, with a doubling strategy for the case of multiple failures.\nThe \n\n\n\n\nH\n\n(\n\u03bb\n+\n1\n)\n\n\n(\nX\n)\n\n\n{\\displaystyle H^{(\\lambda +1)}(X)}\n\n are now generated using the variable shifts \n\n\n\n\ns\n\n\u03bb\n\n\n,\n\n\u03bb\n=\nL\n,\nL\n+\n1\n,\n\u2026\n\n\n{\\displaystyle s_{\\lambda },\\quad \\lambda =L,L+1,\\dots }\n\n which are generated by\nbeing the last root estimate of the second stage and\nIf the step size in stage three does not fall fast enough to zero, then stage two is restarted using a different random point. If this does not succeed after a small number of restarts, the number of steps in stage two is doubled.\nIt can be shown that, provided L is chosen sufficiently large, s\u03bb always converges to a root of P.\nThe algorithm converges for any distribution of roots, but may fail to find all roots of the polynomial. Furthermore, the convergence is slightly faster than the quadratic convergence of Newton\u2013Raphson iteration, however, it uses at least twice as many operations per step.\nCompare with the Newton\u2013Raphson iteration\nThe iteration uses the given P and \n\n\n\n\n\nP\n\n\u2032\n\n\n\n\n\n{\\displaystyle \\scriptstyle P^{\\prime }}\n\n. In contrast the third-stage of Jenkins\u2013Traub\nis precisely a Newton\u2013Raphson iteration performed on certain rational functions. More precisely, Newton\u2013Raphson is being performed on a sequence of rational functions\nFor \n\n\n\n\u03bb\n\n\n{\\displaystyle \\lambda }\n\n sufficiently large,\nis as close as desired to a first degree polynomial\nwhere \n\n\n\n\n\u03b1\n\n1\n\n\n\n\n{\\displaystyle \\alpha _{1}}\n\n is one of the zeros of \n\n\n\nP\n\n\n{\\displaystyle P}\n\n. Even though Stage 3 is precisely a Newton\u2013Raphson iteration, differentiation is not performed.\nLet \n\n\n\n\n\u03b1\n\n1\n\n\n,\n\u2026\n,\n\n\u03b1\n\nn\n\n\n\n\n{\\displaystyle \\alpha _{1},\\dots ,\\alpha _{n}}\n\n be the roots of P(X). The so-called Lagrange factors of P(X) are the cofactors of these roots,\nIf all roots are different, then the Lagrange factors form a basis of the space of polynomials of degree at most n\u00a0\u2212\u00a01. By analysis of the recursion procedure one finds that the H polynomials have the coordinate representation\nEach Lagrange factor has leading coefficient 1, so that the leading coefficient of the H polynomials is the sum of the coefficients. The normalized H polynomials are thus\nIf the condition \n\n\n\n\n|\n\n\n\u03b1\n\n1\n\n\n\u2212\n\ns\n\n\u03ba\n\n\n\n|\n\n<\nmin\n\n\n\n\nm\n=\n2\n,\n3\n,\n\u2026\n,\nn\n\n\n\n|\n\n\n\u03b1\n\nm\n\n\n\u2212\n\ns\n\n\u03ba\n\n\n\n|\n\n\n\n{\\displaystyle |\\alpha _{1}-s_{\\kappa }|<\\min {}_{m=2,3,\\dots ,n}|\\alpha _{m}-s_{\\kappa }|}\n\n holds for almost all iterates, the normalized H polynomials will converge at least geometrically towards \n\n\n\n\nP\n\n1\n\n\n(\nX\n)\n\n\n{\\displaystyle P_{1}(X)}\n\n.\nUnder the condition that\none gets the aymptotic estimates for\nAll stages of the Jenkins\u2013Traub complex algorithm may be represented as the linear algebra problem of determining the eigenvalues of a special matrix. This matrix is the coordinate representation of a linear map in the n-dimensional space of polynomials of degree n\u00a0\u2212\u00a01 or less. The principal idea of this map is to interpret the factorization\nwith a root \n\n\n\n\n\u03b1\n\n1\n\n\n\u2208\n\nC\n\n\n\n{\\displaystyle \\alpha _{1}\\in \\mathbb {C} }\n\n and \n\n\n\n\nP\n\n1\n\n\n(\nX\n)\n=\nP\n(\nX\n)\n\n/\n\n(\nX\n\u2212\n\n\u03b1\n\n1\n\n\n)\n\n\n{\\displaystyle P_{1}(X)=P(X)/(X-\\alpha _{1})}\n\n the remaining factor of degree n\u00a0\u2212\u00a01 as the eigenvector equation for the multiplication with the variable X, followed by remainder computation with divisor P(X),\nThis maps polynomials of degree at most n\u00a0\u2212\u00a01 to polynomials of degree at most n\u00a0\u2212\u00a01. The eigenvalues of this map are the roots of P(X), since the eigenvector equation reads\nwhich implies that \n\n\n\n(\nX\n\u2212\n\u03b1\n)\n\u22c5\nH\n)\n=\nC\n\u22c5\nP\n(\nX\n)\n\n\n{\\displaystyle (X-\\alpha )\\cdot H)=C\\cdot P(X)}\n\n, that is, \n\n\n\n(\nX\n\u2212\n\u03b1\n)\n\n\n{\\displaystyle (X-\\alpha )}\n\n is a linear factor of P(X). In the monomial basis the linear map \n\n\n\n\nM\n\nX\n\n\n\n\n{\\displaystyle M_{X}}\n\n is represented by a companion matrix of the polynomial P, as\nthe resulting coefficient matrix is\nTo this matrix the inverse power iteration is applied in the three variants of no shift, constant shift and generalized Rayleigh shift in the three stages of the algorithm. It is more efficient to perform the linear algebra operations in polynomial arithmetic and not by matrix operations, however, the properties of the inverse power iteration remain the same.\nThe Jenkins\u2013Traub algorithm described earlier works for polynomials with complex coefficients. The same authors also created a three-stage algorithm for polynomials with real coefficients. See Jenkins and Traub A Three-Stage Algorithm for Real Polynomials Using Quadratic Iteration.[5] The algorithm finds either a linear or quadratic factor working completely in real arithmetic. If the complex and real algorithms are applied to the same real polynomial, the real algorithm is about four times as fast. The real algorithm always converges and the rate of convergence is greater than second order.\nThere is a surprising connection with the shifted QR algorithm for computing matrix eigenvalues. See Dekker and Traub The shifted QR algorithm for Hermitian matrices.[6] Again the shifts may be viewed as Newton-Raphson iteration on a sequence of rational functions converging to a first degree polynomial.\nThe software for the Jenkins\u2013Traub algorithm was published as Jenkins and Traub Algorithm 419: Zeros of a Complex Polynomial.[7] The software for the real algorithm was published as Jenkins Algorithm 493: Zeros of a Real Polynomial.[8]\nThe methods have been extensively tested by many people. As predicted they enjoy faster than quadratic convergence for all distributions of zeros.\nHowever, there are polynomials which can cause loss of precision as illustrated by the following example. The polynomial has all its zeros lying on two half-circles of different radii. Wilkinson recommends that it is desirable for stable deflation that smaller zeros be computed first. The second-stage shifts are chosen so that the zeros on the smaller half circle are found first. After deflation the polynomial with the zeros on the half circle is known to be ill-conditioned if the degree is large; see Wilkinson,[9] p.\u00a064. The original polynomial was of degree 60 and suffered severe deflation instability.", 
    "dbpedia_url": "http://dbpedia.org/resource/Jenkins\u2013Traub_algorithm", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Jenkins\u2013Traub_algorithm\n"
}