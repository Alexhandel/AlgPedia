{
    "about": "In mathematics and computing, the Levenberg\u2013Marquardt algorithm (LMA or just LM), also known as the damped least-squares (DLS) method, is used to solve non-linear least squares problems. These minimization problems arise especially in least squares curve fitting.", 
    "name": "Levenberg\u2013Marquardt Algorithm", 
    "classification": "Optimization Algorithms And Methods", 
    "full_text": "In mathematics and computing, the Levenberg\u2013Marquardt algorithm (LMA or just LM), also known as the damped least-squares (DLS) method, is used to solve non-linear least squares problems. These minimization problems arise especially in least squares curve fitting.\nThe LMA is used in many software applications for solving generic curve-fitting problems. However, as for many fitting algorithms, the LMA finds only a local minimum, which is not necessarily the global minimum. The LMA interpolates between the Gauss\u2013Newton algorithm (GNA) and the method of gradient descent. The LMA is more robust than the GNA, which means that in many cases it finds a solution even if it starts very far off the final minimum. For well-behaved functions and reasonable starting parameters, the LMA tends to be a bit slower than the GNA. LMA can also be viewed as Gauss\u2013Newton using a trust region approach.\nThe algorithm was first published in 1944 by Kenneth Levenberg,[1] while working at the Frankford Army Arsenal. It was rediscovered in 1963 by Donald Marquardt[2] who worked as a statistician at DuPont and independently by Girard,[3] Wynne[4] and Morrison.[5]\n\n\nThe primary application of the Levenberg\u2013Marquardt algorithm is in the least-squares curve fitting problem: given a set of \n\n\n\nm\n\n\n{\\displaystyle m}\n\n empirical datum pairs (xi,\u2009yi) of independent and dependent variables, find the parameters \u03b2 of the model curve f(x,\u2009\u03b2) so that the sum of the squares of the deviations is minimized:\nLike other numeric minimization algorithms, the Levenberg\u2013Marquardt algorithm is an iterative procedure. To start a minimization, the user has to provide an initial guess for the parameter vector, \u03b2. In cases with only one minimum, an uninformed standard guess like \u03b2T = (1, 1, ..., 1) will work fine; in cases with multiple minima, the algorithm converges to the global minimum only if the initial guess is already somewhat close to the final solution.\nIn each iteration step, the parameter vector \u03b2 is replaced by a new estimate \u03b2 + \u03b4. To determine \u03b4, the functions \n\n\n\nf\n(\n\nx\n\ni\n\n\n,\n\n\u03b2\n\n+\n\n\u03b4\n\n)\n\n\n{\\displaystyle f(x_{i},{\\boldsymbol {\\beta }}+{\\boldsymbol {\\delta }})}\n\n are approximated by their linearizations:\nwhere\nis the gradient (row-vector in this case) of f with respect to \u03b2.\nThe sum of squares \n\n\n\nS\n(\n\u03b2\n)\n\n\n{\\displaystyle S(\\beta )}\n\n at its minimum has a zero gradient with respect to \u03b2. The above first-order approximation of \n\n\n\nf\n(\n\nx\n\ni\n\n\n,\n\n\u03b2\n\n+\n\n\u03b4\n\n)\n\n\n{\\displaystyle f(x_{i},{\\boldsymbol {\\beta }}+{\\boldsymbol {\\delta }})}\n\n gives\nor in vector notation,\nTaking the derivative of \n\n\n\nS\n(\n\n\u03b2\n\n+\n\n\u03b4\n\n)\n\n\n{\\displaystyle S({\\boldsymbol {\\beta }}+{\\boldsymbol {\\delta }})}\n\n with respect to \u03b4 and setting the result to zero gives\nwhere \n\n\n\n\nJ\n\n\n\n{\\displaystyle \\mathbf {J} }\n\n is the Jacobian matrix whose i-th row equals \n\n\n\n\nJ\n\ni\n\n\n\n\n{\\displaystyle J_{i}}\n\n, and where \n\n\n\n\nf\n\n\n\n{\\displaystyle \\mathbf {f} }\n\n and \n\n\n\n\ny\n\n\n\n{\\displaystyle \\mathbf {y} }\n\n are vectors with i-th component \n\n\n\nf\n(\n\nx\n\ni\n\n\n,\n\n\u03b2\n\n)\n\n\n{\\displaystyle f(x_{i},{\\boldsymbol {\\beta }})}\n\n and \n\n\n\n\ny\n\ni\n\n\n\n\n{\\displaystyle y_{i}}\n\n respectively. This is a set of linear equations, which can be solved for \u03b4.\nLevenberg's contribution is to replace this equation by a \"damped version\",\nwhere I is the identity matrix, giving as the increment \u03b4 to the estimated parameter vector \u03b2.\nThe (non-negative) damping factor \u03bb is adjusted at each iteration. If reduction of S is rapid, a smaller value can be used, bringing the algorithm closer to the Gauss\u2013Newton algorithm, whereas if an iteration gives insufficient reduction in the residual, \u03bb can be increased, giving a step closer to the gradient-descent direction. Note that the gradient of S with respect to \u03b4 equals \n\n\n\n\u2212\n2\n\n\n(\n\n\n\n\nJ\n\n\nT\n\n\n[\n\ny\n\n\u2212\n\nf\n\n(\n\n\u03b2\n\n)\n]\n\n\n\n)\n\n\n\nT\n\n\n\n\n{\\displaystyle -2{\\big (}\\mathbf {J} ^{T}[\\mathbf {y} -\\mathbf {f} ({\\boldsymbol {\\beta }})]{\\big )}^{T}}\n\n. Therefore, for large values of \u03bb, the step will be taken approximately in the direction of the gradient. If either the length of the calculated step \u03b4 or the reduction of sum of squares from the latest parameter vector \u03b2 + \u03b4 fall below predefined limits, iteration stops, and the last parameter vector \u03b2 is considered to be the solution.\nLevenberg's algorithm has the disadvantage that if the value of damping factor \u03bb is large, inverting JTJ\u00a0+\u00a0\u03bbI is not used at all. Marquardt provided the insight that we can scale each component of the gradient according to the curvature, so that there is larger movement along the directions where the gradient is smaller. This avoids slow convergence in the direction of small gradient. Therefore, Marquardt replaced the identity matrix I with the diagonal matrix consisting of the diagonal elements of JTJ, resulting in the Levenberg\u2013Marquardt algorithm:\nA similar damping factor appears in Tikhonov regularization, which is used to solve linear ill-posed problems, as well as in ridge regression, an estimation technique in statistics.\nVarious more or less heuristic arguments have been put forward for the best choice for the damping parameter \u03bb. Theoretical arguments exist showing why some of these choices guarantee local convergence of the algorithm; however, these choices can make the global convergence of the algorithm suffer from the undesirable properties of steepest descent, in particular very slow convergence close to the optimum.\nThe absolute values of any choice depends on how well-scaled the initial problem is. Marquardt recommended starting with a value \u03bb0 and a factor \u03bd > 1. Initially setting \u03bb = \u03bb0 and computing the residual sum of squares S(\u03b2) after one step from the starting point with the damping factor of \u03bb = \u03bb0 and secondly with \u03bb0/\u03bd. If both of these are worse than the initial point, then the damping is increased by successive multiplication by \u03bd until a better point is found with a new damping factor of \u03bb0\u03bdk for some k.\nIf use of the damping factor \u03bb/\u03bd results in a reduction in squared residual, then this is taken as the new value of \u03bb (and the new optimum location is taken as that obtained with this damping factor) and the process continues; if using \u03bb/\u03bd resulted in a worse residual, but using \u03bb resulted in a better residual, then \u03bb is left unchanged and the new optimum is taken as the value obtained with \u03bb as damping factor.\nIn this example we try to fit the function \n\n\n\ny\n=\na\ncos\n\u2061\n(\nb\nX\n)\n+\nb\nsin\n\u2061\n(\na\nX\n)\n\n\n{\\displaystyle y=a\\cos(bX)+b\\sin(aX)}\n\n using the Levenberg\u2013Marquardt algorithm implemented in GNU Octave as the leasqr function. The graphs show progressively better fitting for the parameters a = 100, b = 102 used in the initial curve. Only when the parameters in the last graph are chosen closest to the original, are the curves fitting exactly. This equation is an example of very sensitive initial conditions for the Levenberg\u2013Marquardt algorithm. One reason for this sensitivity is the existence of multiple minima \u2014 the function \n\n\n\ncos\n\u2061\n(\n\u03b2\nx\n)\n\n\n{\\displaystyle \\cos(\\beta x)}\n\n has minima at parameter value \n\n\n\n\n\n\n\u03b2\n^\n\n\n\n\n\n{\\displaystyle {\\hat {\\beta }}}\n\n and \n\n\n\n\n\n\n\u03b2\n^\n\n\n\n+\n2\nn\n\u03c0\n\n\n{\\displaystyle {\\hat {\\beta }}+2n\\pi }\n\n.", 
    "dbpedia_url": "http://dbpedia.org/resource/Levenberg\u2013Marquardt_algorithm", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Levenberg\u2013Marquardt_algorithm\n"
}