{
    "about": "In computing, especially digital signal processing, the multiply\u2013accumulate operation is a common step that computes the product of two numbers and adds that product to an accumulator. The hardware unit that performs the operation is known as a multiplier\u2013accumulator (MAC, or MAC unit); the operation itself is also often called a MAC or a MAC operation. The MAC operation modifies an accumulator a:", 
    "name": "Multiply\u2013Accumulate Operation", 
    "classification": "Digital Signal Processing", 
    "full_text": "In computing, especially digital signal processing, the multiply\u2013accumulate operation is a common step that computes the product of two numbers and adds that product to an accumulator. The hardware unit that performs the operation is known as a multiplier\u2013accumulator (MAC, or MAC unit); the operation itself is also often called a MAC or a MAC operation. The MAC operation modifies an accumulator a:\nWhen done with floating point numbers, it might be performed with two roundings (typical in many DSPs), or with a single rounding. When performed with a single rounding, it is called a fused multiply\u2013add (FMA) or fused multiply\u2013accumulate (FMAC).\nModern computers may contain a dedicated MAC, consisting of a multiplier implemented in combinational logic followed by an adder and an accumulator register that stores the result. The output of the register is fed back to one input of the adder, so that on each clock cycle, the output of the multiplier is added to the register. Combinational multipliers require a large amount of logic, but can compute a product much more quickly than the method of shifting and adding typical of earlier computers. The first processors to be equipped with MAC units were digital signal processors, but the technique is now also common in general-purpose processors.\n\n\nWhen done with integers, the operation is typically exact (computed modulo some power of two). However, floating-point numbers have only a certain amount of mathematical precision. That is, digital floating-point arithmetic is generally not associative or distributive. (See Floating point#Accuracy problems.) Therefore, it makes a difference to the result whether the multiply\u2013add is performed with two roundings, or in one operation with a single rounding (a fused multiply\u2013add). IEEE 754-2008 specifies that it must be performed with one rounding, yielding a more accurate result.[1]\nA fused multiply\u2013add (sometimes known as FMA or fmadd ) [2] is a floating-point multiply\u2013add operation performed in one step, with a single rounding. That is, where an unfused multiply\u2013add would compute the product b\u00d7c, round it to N significant bits, add the result to a, and round back to N significant bits, a fused multiply\u2013add would compute the entire expression a+b\u00d7c to its full precision before rounding the final result down to N significant bits.\nA fast FMA can speed up and improve the accuracy of many computations that involve the accumulation of products:\nFused multiply\u2013add can usually be relied on to give more accurate results. However, William Kahan has pointed out that it can give problems if used unthinkingly.[3] If x2 \u2212 y2 is evaluated as ((x\u00d7x) \u2212 y\u00d7y) using fused multiply\u2013add, then the result may be negative even when x = y due to the first multiplication discarding low significance bits. This could then lead to an error if, for instance, the square root of the result is then evaluated.\nWhen implemented inside a microprocessor, an FMA can actually be faster than a multiply operation followed by an add. However, standard industrial implementations based on the original IBM RS/6000 design require a 2N-bit adder to compute the sum properly.[4][5]\nA useful benefit of including this instruction is that it allows an efficient software implementation of division (see division algorithm) and square root (see methods of computing square roots) operations, thus eliminating the need for dedicated hardware for those operations.[6]\nSome machines combine multiple fused multiply add operations into a single step, e.g. performing a 4-element dot-product on 2 128-bit SIMD registers a0\u00d7b0+a1\u00d7b1+a2\u00d7b2+a3\u00d7b3 with single cycle throughput.\nThe FMA operation is included in IEEE 754-2008.\nThe DEC VAX's POLY instruction is used for evaluating polynomials with Horner's rule using a succession of multiply and add steps. Instruction descriptions do not specify whether the multiply and add are performed using a single fma step.[7] This instruction has been a part of the VAX instruction set since its original 11/780 implementation in 1977.\nThe 1999 standard of the C programming language supports the FMA operation through the fma standard math library function, and standard pragmas controlling optimizations based on FMA.\nThe fused multiply\u2013add operation was introduced as multiply\u2013add fused in the IBM POWER1 (1990) processor,[8] but has been added to numerous other processors since then:", 
    "dbpedia_url": "http://dbpedia.org/resource/Multiply\u2013accumulate_operation", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Multiply\u2013accumulate_operation\n"
}