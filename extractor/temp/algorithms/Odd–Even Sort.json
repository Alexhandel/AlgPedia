{
    "about": "In computing, an odd\u2013even sort or odd\u2013even transposition sort (also known as brick sort[1][self-published source]) is a relatively simple sorting algorithm, developed originally for use on parallel processors with local interconnections. It is a comparison sort related to bubble sort, with which it shares many characteristics. It functions by comparing all odd/even indexed pairs of adjacent elements in the list and, if a pair is in the wrong order (the first is larger than the second) the elements are switched. The next step repeats this for even/odd indexed pairs (of adjacent elements). Then it alternates between odd/even and even/odd steps until the list is sorted.", 
    "name": "Odd\u2013Even Sort", 
    "classification": "Sorting Algorithms", 
    "full_text": "In computing, an odd\u2013even sort or odd\u2013even transposition sort (also known as brick sort[1][self-published source]) is a relatively simple sorting algorithm, developed originally for use on parallel processors with local interconnections. It is a comparison sort related to bubble sort, with which it shares many characteristics. It functions by comparing all odd/even indexed pairs of adjacent elements in the list and, if a pair is in the wrong order (the first is larger than the second) the elements are switched. The next step repeats this for even/odd indexed pairs (of adjacent elements). Then it alternates between odd/even and even/odd steps until the list is sorted.\n\n\nOn parallel processors, with one value per processor and only local left\u2013right neighbor connections, the processors all concurrently do a compare\u2013exchange operation with their neighbors, alternating between odd\u2013even and even\u2013odd pairings. This algorithm was originally presented, and shown to be efficient on such processors, by Habermann in 1972.[2]\nThe algorithm extends efficiently to the case of multiple items per processor. In the Baudet\u2013Stevenson odd\u2013even merge-splitting algorithm, each processor sorts its own sublist at each step, using any efficient sort algorithm, and then performs a merge splitting, or transposition\u2013merge, operation with its neighbor, with neighbor pairing alternating between odd\u2013even and even\u2013odd on each step.[3]\nA related but more efficient sort algorithm is the Batcher odd\u2013even mergesort, using compare\u2013exchange operations and perfect-shuffle operations.[4] Batcher's method is efficient on parallel processors with long-range connections.[5]\nThe single-processor algorithm, like bubblesort, is simple but not very efficient. Here a zero-based index is assumed:\nThis is an example of the algorithm in C++:\nThis is an example of the algorithm in php:\nThis is an example of the algorithm in python:\nThis is an example of the algorithm in MATLAB/OCTAVE:\nClaim: Let \n\n\n\n\na\n\n1\n\n\n,\n.\n.\n.\n,\n\na\n\nn\n\n\n\n\n{\\displaystyle a_{1},...,a_{n}}\n\n be a sequence of data ordered by <. The odd-even sort algorithm correctly sorts this data in \n\n\n\nn\n\n\n{\\displaystyle n}\n\n passes. (A pass here is defined to be a full sequence of odd-even, or even-odd comparisons. The passes occur in order pass 1: odd-even, pass 2: even-odd, etc.)\nProof:\nThis proof is based loosely on one by Thomas Worsch.[6]\nSince the sorting algorithm only involves comparison-swap operations and is oblivious (the order of comparison-swap operations does not depend on the data), by Knuth's 0-1 sorting principle,[7][8] it suffices to check correctness when each \n\n\n\n\na\n\ni\n\n\n\n\n{\\displaystyle a_{i}}\n\n is either 0 or 1. Assume that there are \n\n\n\ne\n\n\n{\\displaystyle e}\n\n 1's.\nObserve that the rightmost 1 can be either in an even or odd position, so it might not be moved by the first odd-even pass. But after the first odd-even pass, the rightmost 1 will be in an even position. It follows that it will be moved to the right by all remaining passes. Since the rightmost one starts in position greater than or equal to \n\n\n\ne\n\n\n{\\displaystyle e}\n\n, it must be moved at most \n\n\n\nn\n\u2212\ne\n\n\n{\\displaystyle n-e}\n\n steps. It follows that it takes at most \n\n\n\nn\n\u2212\ne\n+\n1\n\n\n{\\displaystyle n-e+1}\n\n passes to move the rightmost 1 to its correct position.\nNow, consider the second rightmost 1. After two passes, the 1 to its right will have moved right by at least one step. It follows that, for all remaining passes, we can view the second rightmost 1 as the rightmost 1. The second rightmost 1 starts in position at least \n\n\n\ne\n\u2212\n1\n\n\n{\\displaystyle e-1}\n\n at must be moved to position at most \n\n\n\nn\n\u2212\n1\n\n\n{\\displaystyle n-1}\n\n, so it must be moved at most \n\n\n\n(\nn\n\u2212\n1\n)\n\u2212\n(\ne\n\u2212\n1\n)\n=\nn\n\u2212\ne\n\n\n{\\displaystyle (n-1)-(e-1)=n-e}\n\n steps. After at most 2 passes, the rightmost 1 will have already moved, so the entry to the right of the second rightmost 1 will be 0. Hence, for all passes after the first two, the second rightmost 1 will move to the right. It thus takes at most \n\n\n\nn\n\u2212\ne\n+\n2\n\n\n{\\displaystyle n-e+2}\n\n passes to move the second rightmost 1 to its correct position.\nContinuing in this manner, by induction it can be shown that the \n\n\n\ni\n\n\n{\\displaystyle i}\n\n-th rightmost 1 is moved to its correct position in at most \n\n\n\nn\n\u2212\ne\n+\ni\n+\n1\n\n\n{\\displaystyle n-e+i+1}\n\n passes. It follows that the \n\n\n\ne\n\n\n{\\displaystyle e}\n\n-th rightmost 1 is moved to its correct position in at most \n\n\n\nn\n\u2212\ne\n+\n(\ne\n\u2212\n1\n)\n+\n1\n=\nn\n\n\n{\\displaystyle n-e+(e-1)+1=n}\n\n passes (consider: counting starts at value \"0\"). The list is thus correctly sorted in \n\n\n\nn\n\n\n{\\displaystyle n}\n\n passes. QED.\nWe remark that each pass takes O(n) steps, so this algorithm is O(n^2) complexity.", 
    "dbpedia_url": "http://dbpedia.org/resource/Odd\u2013even_sort", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Odd\u2013even_sort\n"
}