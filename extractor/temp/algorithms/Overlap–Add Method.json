{
    "about": "In signal processing, the overlap\u2013add method (OA, OLA) is an efficient way to evaluate the discrete convolution of a very long signal \n\n\n\nx\n[\nn\n]\n\n\n{\\displaystyle x[n]}\n\n with a finite impulse response (FIR) filter \n\n\n\nh\n[\nn\n]\n\n\n{\\displaystyle h[n]}\n\n:", 
    "name": "Overlap\u2013Add Method", 
    "classification": "Numerical Analysis", 
    "full_text": "In signal processing, the overlap\u2013add method (OA, OLA) is an efficient way to evaluate the discrete convolution of a very long signal \n\n\n\nx\n[\nn\n]\n\n\n{\\displaystyle x[n]}\n\n with a finite impulse response (FIR) filter \n\n\n\nh\n[\nn\n]\n\n\n{\\displaystyle h[n]}\n\n:\nwhere h[m] = 0 for m outside the region [1, M].\nThe concept is to divide the problem into multiple convolutions of h[n] with short segments of \n\n\n\nx\n[\nn\n]\n\n\n{\\displaystyle x[n]}\n\n:\nwhere L is an arbitrary segment length. Then:\nand y[n] can be written as a sum of short convolutions:\nwhere \u00a0\n\n\n\n\ny\n\nk\n\n\n[\nn\n]\n\u00a0\n\n\n\n\n=\n\n\n\nd\ne\nf\n\n\n\n\n\n\u00a0\n\nx\n\nk\n\n\n[\nn\n]\n\u2217\nh\n[\nn\n]\n\n\n\n{\\displaystyle y_{k}[n]\\ {\\stackrel {\\mathrm {def} }{=}}\\ x_{k}[n]*h[n]\\,}\n\n\u00a0 is zero outside the region [1,\u00a0L\u00a0+\u00a0M\u00a0\u2212\u00a01]. \u00a0And for any parameter \u00a0\n\n\n\nN\n\u2265\nL\n+\nM\n\u2212\n1\n,\n\n\n\n{\\displaystyle N\\geq L+M-1,\\,}\n\n\u00a0 it is equivalent to the \n\n\n\nN\n\n\n\n{\\displaystyle N\\,}\n\n-point circular convolution of \n\n\n\n\nx\n\nk\n\n\n[\nn\n]\n\n\n\n{\\displaystyle x_{k}[n]\\,}\n\n with \n\n\n\nh\n[\nn\n]\n\n\n\n{\\displaystyle h[n]\\,}\n\n\u00a0 in the region\u00a0[1,\u00a0N].\nThe advantage is that the circular convolution can be computed very efficiently as follows, according to the circular convolution theorem:\n\n\n\n\n\ny\n\nk\n\n\n[\nn\n]\n=\n\n\nIFFT\n\n\n\n(\n\n\nFFT\n\n\n\n(\n\nx\n\nk\n\n\n[\nn\n]\n)\n\n\u22c5\n\n\nFFT\n\n\n\n(\nh\n[\nn\n]\n)\n\n)\n\n\n\n{\\displaystyle y_{k}[n]={\\textrm {IFFT}}\\left({\\textrm {FFT}}\\left(x_{k}[n]\\right)\\cdot {\\textrm {FFT}}\\left(h[n]\\right)\\right)}\n\n\n\n\u00a0\n\u00a0\n\u00a0\n\u00a0\n(Eq.1)\nwhere FFT and IFFT refer to the fast Fourier transform and inverse fast Fourier transform, respectively, evaluated over \n\n\n\nN\n\n\n{\\displaystyle N}\n\n discrete points.\n\n\nFig. 1 sketches the idea of the overlap\u2013add method. The signal \n\n\n\nx\n[\nn\n]\n\n\n{\\displaystyle x[n]}\n\n is first partitioned into non-overlapping sequences, then the discrete Fourier transforms of the sequences \n\n\n\n\ny\n\nk\n\n\n[\nn\n]\n\n\n{\\displaystyle y_{k}[n]}\n\n are evaluated by multiplying the FFT of \n\n\n\n\nx\n\nk\n\n\n[\nn\n]\n\n\n{\\displaystyle x_{k}[n]}\n\n with the FFT of \n\n\n\nh\n[\nn\n]\n\n\n{\\displaystyle h[n]}\n\n. After recovering of \n\n\n\n\ny\n\nk\n\n\n[\nn\n]\n\n\n{\\displaystyle y_{k}[n]}\n\n by inverse FFT, the resulting output signal is reconstructed by overlapping and adding the \n\n\n\n\ny\n\nk\n\n\n[\nn\n]\n\n\n{\\displaystyle y_{k}[n]}\n\n as shown in the figure. The overlap arises from the fact that a linear convolution is always longer than the original sequences. In the early days of development of the fast Fourier transform, \n\n\n\nL\n\n\n{\\displaystyle L}\n\n was often chosen to be a power of 2 for efficiency, but further development has revealed efficient transforms for larger prime factorizations of L, reducing computational sensitivity to this parameter. A pseudocode of the algorithm is the following:\nWhen sequence x[n] is periodic, and Nx is the period, then y[n] is also periodic, with the same period. \u00a0To compute one period of y[n], Algorithm 1 can first be used to convolve h[n] with just one period of x[n]. \u00a0In the region M \u2264 n \u2264 Nx, \u00a0the resultant y[n] sequence is correct. \u00a0And if the next M\u00a0\u2212\u00a01 values are added to the first M\u00a0\u2212\u00a01 values, then the region 1 \u2264 n \u2264 Nx will represent the desired convolution. The modified pseudocode is:\nThe cost of the convolution can be associated to the number of complex multiplications involved in the operation. The major computational effort is due to the FFT operation, which for a radix-2 algorithm applied to a signal of length \n\n\n\nN\n\n\n{\\displaystyle N}\n\n roughly calls for \n\n\n\nC\n=\n\n\nN\n2\n\n\n\nlog\n\n2\n\n\n\u2061\nN\n\n\n{\\displaystyle C={\\frac {N}{2}}\\log _{2}N}\n\n complex multiplications. It turns out that the number of complex multiplications of the overlap-add method are:\n\n\n\n\n\nC\n\nO\nA\n\n\n\n\n{\\displaystyle C_{OA}}\n\n accounts for the FFT+filter multiplication+IFFT operation.\nThe additional cost of the \n\n\n\n\nM\n\nL\n\n\n\n\n{\\displaystyle M_{L}}\n\n sections involved in the circular version of the overlap\u2013add method is usually very small and can be neglected for the sake of simplicity. The best value of \n\n\n\nN\n\n\n{\\displaystyle N}\n\n can be found by numerical search of the minimum of \n\n\n\n\nC\n\nO\nA\n\n\n\n(\nN\n)\n\n=\n\nC\n\nO\nA\n\n\n\n(\n\n2\n\nm\n\n\n)\n\n\n\n{\\displaystyle C_{OA}\\left(N\\right)=C_{OA}\\left(2^{m}\\right)}\n\n by spanning the integer \n\n\n\nm\n\n\n{\\displaystyle m}\n\n in the range \n\n\n\n\nlog\n\n2\n\n\n\u2061\n\n(\nM\n)\n\n\u2264\nm\n\u2264\n\nlog\n\n2\n\n\n\u2061\n\n(\n\nN\n\nx\n\n\n)\n\n\n\n{\\displaystyle \\log _{2}\\left(M\\right)\\leq m\\leq \\log _{2}\\left(N_{x}\\right)}\n\n. Being \n\n\n\nN\n\n\n{\\displaystyle N}\n\n a power of two, the FFTs of the overlap\u2013add method are computed efficiently. Once evaluated the value of \n\n\n\nN\n\n\n{\\displaystyle N}\n\n it turns out that the optimal partitioning of \n\n\n\nx\n[\nn\n]\n\n\n{\\displaystyle x[n]}\n\n has \n\n\n\nL\n=\nN\n\u2212\nM\n+\n1\n\n\n{\\displaystyle L=N-M+1}\n\n. For comparison, the cost of the standard circular convolution of \n\n\n\nx\n[\nn\n]\n\n\n{\\displaystyle x[n]}\n\n and \n\n\n\nh\n[\nn\n]\n\n\n{\\displaystyle h[n]}\n\n is:\nHence the cost of the overlap\u2013add method scales almost as \n\n\n\nO\n\n(\n\nN\n\nx\n\n\n\nlog\n\n2\n\n\n\u2061\nN\n)\n\n\n\n{\\displaystyle O\\left(N_{x}\\log _{2}N\\right)}\n\n while the cost of the standard circular convolution method is almost \n\n\n\nO\n\n(\n\nN\n\nx\n\n\n\nlog\n\n2\n\n\n\u2061\n\nN\n\nx\n\n\n)\n\n\n\n{\\displaystyle O\\left(N_{x}\\log _{2}N_{x}\\right)}\n\n. However such functions accounts only for the cost of the complex multiplications, regardless of the other operations involved in the algorithm. A direct measure of the computational time required by the algorithms is of much interest. Fig. 2 shows the ratio of the measured time to evaluate a standard circular convolution using \u00a0Eq.1 with the time elapsed by the same convolution using the overlap\u2013add method in the form of Alg 2, vs. the sequence and the filter length. Both algorithms have been implemented under Matlab. The bold line represent the boundary of the region where the overlap\u2013add method is faster (ratio>1) than the standard circular convolution. Note that the overlap\u2013add method in the tested cases can be three times faster than the standard method.", 
    "dbpedia_url": "http://dbpedia.org/resource/Overlap\u2013add_method", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Overlap\u2013add_method\n"
}