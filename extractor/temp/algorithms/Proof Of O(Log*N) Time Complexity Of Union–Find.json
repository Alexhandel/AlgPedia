{
    "about": "In computer science, Union Find is an algorithm for doing certain operations on sets. This page is about proof of O(log*n) amortized time [1] of Union Find[2][3][4]", 
    "name": "Proof Of O(Log*N) Time Complexity Of Union\u2013Find", 
    "classification": "Search Algorithms", 
    "full_text": "In computer science, Union Find is an algorithm for doing certain operations on sets. This page is about proof of O(log*n) amortized time [1] of Union Find[2][3][4]\nStatement: If m operations, either Union or Find, are applied to n elements, the total run time is O(m\u00a0log*n), where log* is the iterated logarithm.\nLemma 1: As the find function follows the path along to the root, the rank of node it encounters is increasing.\nLemma 2: A node u which is root of a subtree with rank r has at least 2r nodes.\nLemma 3: The maximum number of nodes of rank r is at most n/2r.\nFor convenience, we define \"bucket\" here: a bucket is a set that contains vertices with particular ranks.\nWe create some buckets and put vertices into the buckets according to their ranks inductively. That is, vertices with rank 0 go into the zeroth bucket, vertices with rank 1 go into the first bucket, vertices with ranks 2 and 3 go into the second bucket. If the Bth bucket contains vertices with ranks from interval [r, 2r \u2212 1] = [r, R - 1] then the (B+1)st bucket will contain vertices with ranks from interval [R, 2R \u2212 1].\nWe can make two observations about the buckets.\nLet F represent the list of \"find\" operations performed, and let\n\n\n\n\n\nT\n\n1\n\n\n=\n\n\u2211\n\nF\n\n\n\n(link to the root)\n\n\n\n{\\displaystyle T_{1}=\\sum _{F}{\\text{(link to the root)}}}\n\n\n\n\n\n\n\nT\n\n2\n\n\n=\n\n\u2211\n\nF\n\n\n\n(number of links traversed where the buckets are different)\n\n\n\n{\\displaystyle T_{2}=\\sum _{F}{\\text{(number of links traversed where the buckets are different)}}}\n\n\n\n\n\n\n\nT\n\n3\n\n\n=\n\n\u2211\n\nF\n\n\n\n(number of links traversed where the buckets are the same).\n\n\n\n{\\displaystyle T_{3}=\\sum _{F}{\\text{(number of links traversed where the buckets are the same).}}}\n\n\nThen the total cost of m finds is T = T1 + T2 + T3\nSince each find operation makes exactly one traversal that leads to a root, we have T1 = O(m).\nAlso, from the bound above on the number of buckets, we have T2 = O(mlog*n).\nFor T3, suppose we are traversing from u to v, where u and v have rank in the bucket [B, 2B \u2212 1]. From lemma 1, we know that the number of times we traversed a link (u,v) where u and v were in the same bucket is at most 2B \u2212 1 \u2212 B, which is at most 2B.\nTherefore, \n\n\n\n\nT\n\n3\n\n\n=\n\n\u2211\n\n[\nB\n,\n\n2\n\nB\n\n\n\u2212\n1\n]\n\n\n\n\u2211\n\nu\n\n\n\n2\n\nB\n\n\n\n\n{\\displaystyle T_{3}=\\sum _{[B,2^{B}-1]}\\sum _{u}2^{B}}\n\n\nFrom Observations 1 and 2, we can conclude that \n\n\n\n\nT\n\n3\n\n\n\u2264\n\n\u2211\n\nB\n\n\n\n2\n\nB\n\n\n\n\n\n2\nn\n\n\n2\n\nB\n\n\n\n\n\u2264\n2\nn\n\nlog\n\n\u2217\n\n\n\u2061\nn\n.\n\n\n{\\displaystyle T_{3}\\leq \\sum _{B}2^{B}{\\frac {2n}{2^{B}}}\\leq 2n\\log ^{*}n.}\n\n\nTherefore, T = T1 + T2 + T3 = O(m log*n).", 
    "dbpedia_url": "http://dbpedia.org/resource/Proof_of_O(log*n)_time_complexity_of_union\u2013find", 
    "wikipedia_url": "http://en.wikipedia.org/wiki/Proof_of_O(log*n)_time_complexity_of_union\u2013find\n"
}