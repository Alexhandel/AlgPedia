
{ "head": { "link": [], "vars": ["paradigm", "wpage", "abstract", "label"] },
  "results": { "distinct": false, "ordered": true, "bindings": [
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Defensive_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Defensive_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Defensive programming is a form of defensive design intended to ensure the continuing function of a piece of software under unforeseen circumstances. The idea can be viewed as reducing or eliminating the prospect of Finagle's law having effect. Defensive programming techniques are used especially when a piece of software could be misused.Defensive programming is an approach to improve software and source code, in terms of: General quality - reducing the number of software bugs and problems. Making the source code comprehensible - the source code should be readable and understandable so it is approved in a code audit. Making the software behave in a predictable manner despite unexpected inputs or user actions.Overly defensive programming however introduces code to prevent errors that can't happen, but needs to be executed on runtime and to be maintained by the developers, thus increasing the runtime and maintenance costs. There is also the risk that the code catches or prevents too many exceptions. In those cases, the error would be suppressed and go unnoticed, while the result would be still wrong." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Defensive programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Event-driven_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Event-driven_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer programming, event-driven programming is a programming paradigm in which the flow of the program is determined by events such as user actions (mouse clicks, key presses), sensor outputs, or messages from other programs/threads. Event-driven programming is the dominant paradigm used in graphical user interfaces and other applications (e.g. JavaScript web applications) that are centered on performing certain actions in response to user input.In an event-driven application, there is generally a main loop that listens for events, and then triggers a callback function when one of those events is detected. In embedded systems the same may be achieved using hardware interrupts instead of a constantly running main loop. Event-driven programs can be written in any programming language, although the task is easier in languages that provide high-level abstractions, such as closures." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Event-driven programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Ousterhout's_dichotomy" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Ousterhout's_dichotomy" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Ousterhout's dichotomy is computer scientist John Ousterhout's claim that high-level programming languages tend to fall into two groups, each with distinct properties and uses: system programming languages and scripting languages \u2013 compare programming in the large and programming in the small. This distinction underlies the design of his language Tcl.System programming languages (or applications languages) usually have the following properties: They are typed statically They support creating complex data structures Programs in them are compiled into machine code Programs in them are meant to operate largely independently of other programsSystem programming languages tend to be used for components and applications with large amounts of internal functionality such as operating systems, database servers, and Web browsers.  These applications typically employ complex algorithms and data structures and require high performance. Prototypical examples of system programming languages include C and Modula-2.By contrast, scripting languages (or glue languages) tend to have the following properties: They are typed dynamically They have little or no provision for complex data structures Programs in them (scripts) are interpretedScripting languages tend to be used for applications where most of the functionality comes from other programs (often implemented in system programming languages); the scripts are used to glue together other programs or add additional layers of functionality on top of existing programs.  Ousterhout claims that scripts tend to be short and are often written by less sophisticated programmers, so execution efficiency is less important than simplicity and ease of interaction with other programs.  Common applications for scripting include Web page generation, report generation, graphical user interfaces, and system administration. Prototypical examples of scripting languages include AppleScript, C shell, DOS batch files, and Tcl." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Ousterhout's dichotomy" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Partitioned_global_address_space" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Partitioned_global_address_space" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, a partitioned global address space (PGAS) is a parallel programming model. It assumes a global memory address space that is logically partitioned and a portion of it is local to each process or thread. The novelty of PGAS is that the portions of the shared memory space may have an affinity for a particular process, thereby exploiting locality of reference. The PGAS model is the basis of Unified Parallel C, Coarray Fortran, Fortress, Chapel, X10, and Global Arrays. PGAS attempts to combine the advantages of a SPMD programming style for distributed memory systems (as employed by MPI) with the data referencing semantics of shared memory systems. This is more realistic than the traditional shared memory approach of one flat address space, because hardware-specific data locality can be modeled in the partitioning of the address space.A variant of the PGAS model, asynchronous partitioned global address space (APGAS) permits both local and remote asynchronous task creation.  Two programming languages that use this model are Chapel and X10." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Partitioned global address space" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Jackson_structured_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Jackson_structured_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Jackson structured programming (JSP) is a method for structured programming based on correspondences between data stream structure and program structure.  JSP structures programs and data in terms of sequences, iterations and selections, and as a consequence it is applied when designing a program's detailed control structure, below the level where  object-oriented methods become important." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Jackson structured programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Functional_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Functional_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, functional programming is a programming paradigm, a style of building the structure and elements of computer programs, that treats computation as the evaluation of mathematical functions and avoids changing-state and mutable data. It is a declarative programming paradigm, which means programming is done with expressions. In functional code, the output value of a function depends only on the arguments that are input to the function, so calling a function f twice with the same value for an argument x will produce the same result f(x) each time. Eliminating side effects, i.e. changes in state that do not depend on the function inputs, can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming.Functional programming has its roots in lambda calculus, a formal system developed in the 1930s to investigate computability, the Entscheidungsproblem, function definition, function application, and recursion. Many functional programming languages can be viewed as elaborations on the lambda calculus. In the other well-known declarative programming paradigm, logic programming, relations are at the base of respective languages.In contrast, imperative programming changes state with commands in the source language, the most simple example being assignment. Imperative programming does have functions, not in the mathematical sense, but in the sense of subroutines. They can have side effects that may change the value of program state. Functions without return values therefore make sense. Because of this, they lack referential transparency, i.e. the same language expression can result in different values at different times depending on the state of the executing program.Functional programming languages, especially purely functional ones such as Hope and Rex, have largely been emphasized in academia rather than in commercial software development. However, prominent functional programming languages such as Common Lisp, Scheme, Clojure, Racket, Erlang, OCaml, Haskell, and F# have been used in industrial and commercial applications by a wide variety of organizations. Functional programming is also supported in some domain-specific programming languages like R (statistics), Wolfram Language (also known as M or Mathematica, for symbolic and numeric math), J, K and Q from Kx Systems (financial analysis), XQuery/XSLT (XML), and Opal. Widespread domain-specific declarative languages like SQL and Lex/Yacc use some elements of functional programming, especially in eschewing mutable values.Programming in a functional style can also be accomplished in languages that aren\u2019t specifically designed for functional programming. For example, the imperative Perl programming language has been the subject of a book describing how to apply functional programming concepts. This is also true of the PHP programming language. C# 3.0 and Java 8 added constructs to facilitate the functional style. An interesting case is that of Scala \u2013 it is frequently written in a functional style, but the presence of side effects and mutable state place it in a grey area between imperative and functional languages." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Functional programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Knowledge_representation_and_reasoning" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Knowledge_representation_and_reasoning" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Knowledge representation and reasoning (KR) is the field of artificial intelligence (AI) dedicated to representing information about the world in a form that a computer system can utilize to solve complex tasks such as diagnosing a medical condition or having a dialog in a natural language. Knowledge representation incorporates findings from psychology about how humans solve problems and represent knowledge in order to design formalisms that will make complex systems easier to design and build.  Knowledge representation and reasoning also incorporates findings from logic to automate various kinds of reasoning, such as the application of rules or the relations of sets and subsets.Examples of knowledge representation formalisms include semantic nets, Frames, Rules, and ontologies. Examples of automated reasoning engines include inference engines, theorem provers, and classifiers." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Knowledge representation and reasoning" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Logic_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Logic_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Logic programming is a programming paradigm based on formal logic. A program written in a logic programming language is a set of sentences in logical form, expressing facts and rules about some problem domain.  Major logic programming language families include Prolog, Answer set programming (ASP) and Datalog. In all of these languages, rules are written in the form of clauses:H :- B1, \u2026, Bn.and are read declaratively as logical implications:H if B1 and \u2026 and Bn.H is called the head of the rule and B1, \u2026, Bn is called the body. Facts are rules that have no body, and are written in the simplified form:H.In the simplest case in which H, B1, \u2026, Bn are all atomic formulae, these clauses are called definite clauses or Horn clauses. However, there exist many extensions of this simple case, the most important one being the case in which conditions in the body of a clause can also be negations of atomic formulae. Logic programming languages that include this extension have the knowledge representation capabilities of a non-monotonic logic.In ASP and Datalog, logic programs have only a declarative reading, and their execution is performed by means of a proof procedure or model generator whose behaviour is not meant to be under the control of the programmer. However, in the Prolog family of languages, logic programs also have a procedural interpretation as goal-reduction procedures:to solve H, solve B1, and ... and solve Bn.Consider, for example, the following clause:fallible(X) :- human(X).based on an example used by Terry Winograd  to illustrate the programming language Planner. As a clause in a logic program, it can be used both as a procedure to test whether X is fallible by testing whether X is human, and as a procedure to find  an X that is fallible by finding an X that is human. Even facts have a procedural interpretation. For example, the clause:human(socrates).can be used both as a procedure to show that socrates is human, and as a procedure to find  an X that is human by \"assigning\" socrates to X.The declarative reading of logic programs can be used by a programmer to verify their correctness. Moreover, logic-based program transformation techniques can also be used to transform logic programs into logically equivalent programs that are more efficient. In the Prolog family of logic programming languages, the programmer can also use the known problem-solving behaviour of the execution mechanism to improve the efficiency of programs." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Logic programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Procedural_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Procedural_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Procedural programming is a programming paradigm, derived from structured programming, based upon the concept of the procedure call.  Procedures, also known as routines, subroutines, methods, or functions (not to be confused with mathematical functions, but similar to those used in functional programming), simply contain a series of computational steps to be carried out.  Any given procedure might be called at any point during a program's execution, including by other procedures or itself.Procedural programming is a list or set of instructions telling a computer what to do  step by step and how to perform from the first code to the second code. Procedural programming languages include C, Go, Fortran, Pascal, and BASIC." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Procedural programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Intentional_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Intentional_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer programming, Intentional Programming is a programming paradigm developed by Charles Simonyi that encodes in software source code the precise intention which programmers (or users) have in mind when conceiving their work. By using the appropriate level of abstraction at which the programmer is thinking, creating and maintaining computer programs become easier. By separating the concerns for intentions and how they are being operated upon, the software becomes more modular and allows for more reusable software code. The Intentional Programming was developed by former Microsoft chief architect Charles Simonyi, who led a team in Microsoft Research which developed the paradigm and built an integrated development environment (IDE) called IP (for Intentional Programming) that demonstrated the paradigm. Microsoft decided not to productize the Intentional Programming paradigm, as in the early 2000s Microsoft was rolling out C# and .NET to counter Java adoption.  Charles Simonyi decided, with approval of Microsoft, to take his idea out from Microsoft and commercialize it himself. He founded the company Intentional Software to pursue this. Microsoft licensed the Intentional Programming patents Simonyi had acquired while at Microsoft, but no source code, to Intentional Software. An overview of Intentional Programming as it was developed at Microsoft Research is given in Chapter 11 of the book Generative Programming: Methods, Tools, and Applications." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Intentional programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Inductive_functional_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Inductive_functional_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Inductive Functional Programming (IFP) is a special kind of inductive programming that uses functional programs as representation for examples, programs and background knowledge. The term is frequently used to make a distinction from inductive logic programming, which uses logic programs." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Inductive functional programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Self-modifying_code" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Self-modifying_code" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, self-modifying code is code that alters its own instructions while it is executing - usually to reduce the instruction path length and improve performance or simply to reduce otherwise repetitively similar code, thus simplifying maintenance. Self modification is an alternative to the method of \"flag setting\" and conditional program branching, used primarily to reduce the number of times a condition needs to be tested. The term is usually only applied to code where the self-modification is intentional, not in situations where code accidentally modifies itself due to an error such as a buffer overflow.The method is frequently used for conditionally invoking test/debugging code without requiring additional computational overhead for every input/output cycle.The modifications may be  performed: only during initialization - based on input parameters (when the process is more commonly described as software 'configuration' and is somewhat analogous, in hardware terms, to setting jumpers for printed circuit boards). Alteration of program entry pointers is an equivalent indirect method of self-modification, but requiring the co-existence of one or more alternative instruction paths, increasing the program size. throughout execution ('on-the-fly') - based on particular program states that have been reached during the executionIn either case, the modifications may be performed directly to the machine code instructions themselves, by overlaying new instructions over the existing ones (for example: altering a compare and branch to an unconditional branch or alternatively a 'NOP'). In the IBM/360 and Z/Architecture instruction set, an EXECUTE (EX) instruction logically overlays the second byte of its target instruction with the low-order 8 bits of register 1. This provides the effect of self-modification although the actual instruction in storage is not altered." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Self-modifying code" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Write_once,_compile_anywhere" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Write_once,_compile_anywhere" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Write once, compile anywhere (WOCA) is a philosophy taken by a software platform which refers to a capability of writing a computer program that can be compiled on all platforms without the need to modify its source code. As opposed to Sun's write once, run anywhere slogan, cross-platform compatibility is implemented only at the source code level, rather than also at the compiled binary code level.There are many languages that follow the WOCA philosophy, such as C++, Pascal (see Free Pascal), Ada or C, on condition that they don't use functions beyond those provided by the standard library. A computer program may also use cross-platform libraries, which provide an abstraction layer hiding the differences between various platforms, for things like sockets and GUI, ensuring the portability of the written source code. This is e.g. supported by Qt or the Lazarus IDE via its LCL and corresponding widgetsets." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Write once, compile anywhere" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Programming_by_example" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Programming_by_example" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, programming by example (PbE), also known as programming by demonstration or more generally as demonstrational programming, is an End-user development technique for teaching a computer new behavior by demonstrating actions on concrete examples. The system records user actions and infers a generalized program that can be used upon new examples.PbE is intended to be easier than traditional programming, which generally requires learning and using a programming language.  Many PbE systems have been developed as research prototypes, but few have found widespread real-world application.  More recently, PbE has proved to be a useful paradigm for creating scientific work-flows. PbE is used in two independent clients for the BioMOBY protocol: Seahawk and Gbrowse moby. Also the programming by demonstration term has been mostly adopted by robotics researchers for teaching new behaviors to the robot through a physical demonstration of the task." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Programming by example" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Programming_by_demonstration" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Programming_by_demonstration" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, programming by demonstration (PbD) is an End-user development technique for teaching a computer or a robot new behaviors by demonstrating the task totransfer directly instead of programming it through machine commands.The terms programming by example (PbE) and programming by demonstration (PbD) appeared in software development research as early as the mid 1980s to define a way to define a sequence of operations without having to learn a programming language. The usual distinction in literature between these terms is that in PbE the user gives a prototypical product of the computer execution, such as a row in the desired results of a query; while in PbD the user performs a sequence of actions that the computer must repeat, generalizing it to be used in different data sets.These two terms were first undifferentiated, but PbE then tended to be mostly adopted by software development researchers while PbD tended to be adopted by robotics researchers. Today, PbE refers to an entirely different concept, supported by new programming languages that are similar to simulators." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Programming by demonstration" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Uniform_access_principle" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Uniform_access_principle" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "The Uniform Access Principle was put forth by Bertrand Meyer.  It states \"All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation\". This principle applies generally to the syntax of object-oriented programming languages. In simpler form, it states that there should be no difference between working with an attribute, precomputed property, or method/query.While most examples focus on the \"read\" aspect of the principle, Meyer shows that the \"write\" implications of the principle are harder to deal with in his monthly column on the Eiffel programming language official website." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Uniform access principle" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Flow-based_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Flow-based_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer programming, flow-based programming (FBP) is a programming paradigm that defines applications as networks of \"black box\" processes, which exchange data across predefined connections by message passing, where the connections are specified externally to the processes. These black box processes can be reconnected endlessly to form different applications without having to be changed internally. FBP is thus naturally component-oriented.FBP is a particular form of dataflow programming based on bounded buffers, information packets with defined lifetimes, named ports, and separate definition of connections." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Flow-based programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Role-oriented_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Role-oriented_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Role-oriented programming is a form of computer programming aimed at expressing things in terms which are analogous to human conceptual understanding of the world. This should make programs easier to understand and maintain. The main idea of role-oriented programming is that humans think in terms of roles. This claim is often backed up by examples of social relations. For example, a student attending a class and the same student at a party are the same person, yet he plays two different roles. In particular, the interactions of this person with the outside world depend on his current role. The roles typically share features, e.g., the intrinsic properties of being a person. This sharing of properties is often handled by the delegation mechanism.In the older literature and in the field of databases, it seems that there has been little consideration for  the context in which roles interplay with each other. Such a context is being established in newer role- and aspect-oriented programming languages such as Object Teams.Many researchers have argued the advantages of roles in modeling and implementation. Roles allow objects to evolve over time, they enable independent and concurrently existing views (interfaces) of the object, explicating the different contexts of the object, and separating concerns. Generally roles are a natural element of our daily concept forming. Roles in programming languages enable objects to have changing interfaces, as we see it in real life - things change over time, are used differently in different contexts, etc.A complete overview and taxonomy of Role languages is provided in the Ph.D. thesis [1]" }	, "label": { "type": "literal", "xml:lang": "en", "value": "Role-oriented programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Nondeterministic_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Nondeterministic_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "A nondeterministic programming language is a language which can specify, at certain points in the program (called \"choice points\"), various alternatives for program flow. Unlike an if-then statement, the method of choice between these alternatives is not directly specified by the programmer; the program must decide at run time between the alternatives, via some general method applied to all choice points. A programmer specifies a limited number of alternatives, but the program must later choose between them. (\"Choose\" is, in fact, a typical name for the nondeterministic operator.) A hierarchy of choice points may be formed, with higher-level choices leading to branches that contain lower-level choices within them.One method of choice is embodied in backtracking systems (such as AMB, or unification in Prolog), in which some alternatives may \"fail,\" causing the program to backtrack and try other alternatives. If all alternatives fail at a particular choice point, then an entire branch fails, and the program will backtrack further, to an older choice point. One complication is that, because any choice is tentative and may be remade, the system must be able to restore old program states by undoing side-effects caused by partially executing a branch that eventually failed.Another method of choice is reinforcement learning, embodied in systems such as Alisp. In such systems, rather than backtracking, the system keeps track of some measure of success and learns which choices often lead to success, and in which situations (both internal program state and environmental input may affect the choice). These systems are suitable for applications to robotics and other domains in which backtracking would involve attempting to undo actions performed in a dynamic environment, which may be difficult or impractical." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Nondeterministic programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Inductive_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Inductive_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Inductive Programming (IP) is a special area of automatic programming, covering research from artificial intelligence and programming, which addresses learning of typically declarative (logic or functional) and often recursive programs from incomplete specifications, such as input/output examples or constraints.Depending on the programming language used, there are several kinds of inductive programming. Inductive functional programming, which uses functional programming languages such as Lisp or Haskell, and most especially Inductive logic programming, which uses logic programming languages such as Prolog and other logical representations  such as Description logics, have been more prominent, but other (programming) language paradigms have also been used, such as constraint programming or probabilistic programming." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Inductive programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/SequenceL" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/SequenceL" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "SequenceL is a general purpose functional programming language, whose primary design objectives are performance on multicore hardware, ease of programming, and code clarity/readability.  Its primary advantage is that it can be used to write straightforward code that automatically takes full advantage of all the processing power available, without the developer having to concern themselves with identifying parallelisms, avoiding race conditions, and the like.Programs written in SequenceL can be compiled to multithreaded code that runs in parallel with no explicit indications from the programmer of how or what to parallelize.  (Current versions of the SequenceL compiler generate C++ and OpenCL code, though other languages may also be supported.)  An OS-specific runtime manages the threads safely, automatically providing parallel performance according to the cores available." }	, "label": { "type": "literal", "xml:lang": "en", "value": "SequenceL" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Concurrent_logic_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Concurrent_logic_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Concurrent logic programming is a variant of logic programming in which programs are sets of guarded Horn clauses of the form:H :- G1, \u2026, Gn | B1, \u2026, Bn.The conjunction G1, \u2026 , Gn is called the guard of the clause, and   |  is the commitment operator. Declaratively, guarded Horn clauses are read as ordinary logical implications:H if G1 and \u2026 and Gn and B1 and \u2026 and Bn.However, procedurally,  when there are several clauses whose heads  H  match a given goal, then all of the clauses are executed in parallel, checking whether their  guards G1, \u2026 , Gn hold. If the guards of more than one clause hold, then a committed choice is made to one of the clauses, and execution proceedes with the subgoals   B1, \u2026, Bn  of the chosen clause. These subgoals can also be executed in parallel. Thus concurrent logic programming implements a form of \"don't care nondeterminism\", ratherthan \"don't know nondeterminism\"." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Concurrent logic programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Interface-based_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Interface-based_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Interface-based programming  is a concept that has a close relationship with Modular programming and Object-Oriented Programming.Modular Programming defines the application as a collection of intercoupled modules. This increases the modularity of the application and hence its maintainability. The total system complexity is greatly reduced. Interface Based Programming adds more to  modular Programming in that it insists that Interfaces are to be added to these modules. The entire system is thus viewed as Components and the interfaces that helps them to coact.This is particularly convenient when third parties develop additional components for the established system. They just have to develop components that satisfy the interface specified by the parent application vendor. This is somewhat like a mobile phone manufacturer specifying a Mobile Charger Interface and third parties making their own Mobile Phone Chargers, adhering to these standards/Interface(Pin Arrangement, AC-DC Conversion Voltages etc.).Another example is IEEE 1394 (Firewire) being accepted by both your Laptop manufacturer and your Digital Camera manufacturer.Thus the publisher of the interfaces assures that he will not change the interface and the subscriber agrees to implement the interface as whole without any deviation.An interface is therefore said to be a Contractual agreement and the programming paradigm  based on this is termed as \"interface based programming\"." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Interface-based programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Symbolic_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Symbolic_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer programming, symbolic programming is a programming paradigm in which the program can manipulate its own formulas and program components as if they were plain data.Through symbolic programming, complex processes can be developed that build other more intricate processes by combining smaller units of logic or functionality.  Thus, such programs can effectively modify themselves and appear to \"learn\", what makes them better suited for applications such as artificial intelligence, expert systems, natural language processing, and computer games.Languages that support symbolic programming include LISP and Prolog." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Symbolic programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Design_by_contract" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Design_by_contract" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Design by contract (DbC), also known as contract programming, programming by contract and design-by-contract programming, is an approach for designing software. It prescribes that software designers should define formal, precise and verifiable interface specifications for software components, which extend the ordinary definition of abstract data types with preconditions, postconditions and invariants. These specifications are referred to as \"contracts\", in accordance with a conceptual metaphor with the conditions and obligations of business contracts." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Design by contract" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Relational_model" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Relational_model" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "The relational model for database management is a database model based on first-order predicate logic,  first formulated and proposed in 1969 by Edgar F. Codd. In the relational model of a database, all data is represented in terms of tuples, grouped into relations. A database organized in terms of the relational model is a relational database.The purpose of the relational model is to provide a declarative method for specifying data and queries: users directly state what information the database contains and what information they want from it, and let the database management system software take care of describing data structures for storing the data and retrieval procedures for answering queries.Most relational databases use the SQL data definition and query language; these systems implement what can be regarded as an engineering approximation to the relational model. A table in an SQL database schema corresponds to a predicate variable; the contents of a table to a relation; key constraints, other constraints, and SQL queries correspond to predicates. However, SQL databases deviate from the relational model in many details, and Codd fiercely argued against deviations that compromise the original principles." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Relational model" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Structured_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Structured_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Structured programming is a programming paradigm aimed at improving the clarity, quality, and development time of a computer program by making extensive use of subroutines, block structures and for and while loops\u2014in contrast to using simple tests and jumps such as the goto statement which could lead to \"spaghetti code\" which is difficult both to follow and to maintain.It emerged in the 1960s\u2014particularly from a famous letter, Go To Statement Considered Harmful.\u2014and was bolstered theoretically by the structured program theorem, and practically by the emergence of languages such as ALGOL with suitably rich control structures." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Structured programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Comparison_of_multi-paradigm_programming_languages" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Comparison_of_multi-paradigm_programming_languages" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Programming languages can be grouped by the number and types of paradigms supported." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Comparison of multi-paradigm programming languages" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Core_concern" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Core_concern" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, a core concern is one of the main concerns a program is written for. The main coding of the application is to satisfy the core concerns, such as doing the tasks as visualized. Other coding which is to document changes, maintain histories and other non-direct actions supportive of the core tasks are not core concerns." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Core concern" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/ARS-based_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/ARS-based_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "ARS-based programming is built on three principles: Abstraction, Reference and Synthesis. These principles can be seen as a generalized form of the basic operations of the Lambda calculus. All essential features of a programming language can be derived from ARS even the three major programming paradigms: functional programming, object-oriented programming and imperative programming.The programming language A++ is a demonstration that, based on ARS, programming patterns can be developed that are very powerful, providing a solid base for solving common programming problems.ARS-based programming as covered in the book Programmierung pur (Undiluted Programming or Barebones Programming) published in German under the ISBN 3-87820-108-7 (the English rights are available now) is facilitated by three tools: A++, ARS++, and ARSAPI. A++, a minimal programming language with interpreter for basic training enforcing rigorous confrontation with the essentials of programming; ARS++, a full blown programming language including a virtual machine and compiler, extending A++ into a language that is fully ars-compatible with a functionality going beyond that of Scheme with the power of coping with the challenges of real world programming; ARSAPI, a bridge between ARS and popular programming languages like Java, C and C++, consisting of definitions and patterns recommended to express ARS in the target language." }	, "label": { "type": "literal", "xml:lang": "en", "value": "ARS-based programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Set_theoretic_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Set_theoretic_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Set theoretic programming is a programming paradigm based on mathematical set theory. One example of a programming language based on this paradigm is SETL.  The goal of set theoretic programming is to improve programmer speed and productivity significantly, and also enhance program clarity and readability." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Set theoretic programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Signal_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Signal_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Signal programming is used in the same sense as dataflow programming, and is similar to event-driven programming.The word signal is used instead of the word dataflow in documentation of such libraries as Qt, GTK+ and libsigc++. The time instants when the signal value (or dataflow value) changes correspond to events in event-driven programming. The signal flow of a program or a signal processing system is described graphically in a signal-flow graph or a data-flow diagram." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Signal programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Value-level_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Value-level_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Value-level programming refers to one of the two contrasting programming paradigms identified by John Backus in his work on programs as mathematical objects, the other being function-level programming. Backus originally used the term object-level programming but that term is now prone to confusion with object-oriented programming.Value-level programs are those that describe how to combine various values (i.e., numbers, symbols, strings, etc.) to form other values until the final result values are obtained. New values are constructed from existing ones by the application of various value-to-value functions, such as addition, concatenation, matrix inversion, and so on.Conventional, von Neumann programs are value-level: expressions on the right side of assignment statements are exclusively concerned with building a value that is then to be stored." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Value-level programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Automata-based_programming_(Shalyto's_approach)" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Automata-based_programming_(Shalyto's_approach)" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Automata-Based Programming is a programming technology (Nepeyvoda 2005). Its defining characteristic is the use of finite state machines to describe program behavior. The transition graphs of state machines are used in all stages of software development (specification, implementation, debugging and documentation). Automata-Based Programming technology was introduced by Anatoly Shalyto in 1991 (Shalyto 1991). Switch-technology (Shalyto 1998) was developed to support automata-based programming. Automata-Based Programming is considered to be rather general purpose program development methodology than just another one finite state machine implementation." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Automata-based programming (Shalyto's approach)" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Concurrent_constraint_logic_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Concurrent_constraint_logic_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Concurrent constraint logic programming is a version of constraint logic programming aimed primarily at programming concurrent processes rather than (or in addition to) solving constraint satisfaction problems. Goals in constraint logic programming are evaluated concurrently; a concurrent process is therefore programmed as the evaluation of a goal by the interpreter.Syntactically, concurrent constraints logic programs are similar to non-concurrent programs, the only exception being that clauses include guards, which are constraints that may block the applicability of the clause under some conditions. Semantically, concurrent constraint logic programming differs from its non-concurrent versions because a goal evaluation is intended to realize a concurrent process rather than finding a solution to a problem. Most notably, this difference affects how the interpreter behaves when more than one clause is applicable: non-concurrent constraint logic programming recursively tries all clauses; concurrent constraint logic programming chooses only one. This is the most evident effect of an intended directionality of the interpreter, which never revise a choice it has previously taken. Other effects of this are the semantical possibility of having a goal that cannot be proved while the whole evaluation does not fail, and a particular way for equating a goal and a clause head.Constraint handling rules can be seen as a form of concurrent constraint logic programming, but are used for programming a constraint simplifier or solver rather than concurrent processes." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Concurrent constraint logic programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Non-structured_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Non-structured_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Non-structured programming is the historically earliest programming paradigm capable of creating Turing-complete algorithms. It has been followed historically by procedural programming and then object-oriented programming, both of them considered as structured programming. Unstructured programming has been heavily criticized for producing hardly-readable (\"spaghetti\") code and is sometimes considered a bad approach for creating major projects, but had been praised for the freedom it offers to programmers and has been compared to how Mozart wrote music.There are both high- and low-level programming languages that use non-structured programming. These include early versions of BASIC (such as MSX BASIC and GW-BASIC), JOSS, FOCAL, MUMPS, TELCOMP, COBOL, machine-level code, early assembler systems (without procedural metaoperators), assembler debuggers and some scripting languages such as MS-DOS batch file language." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Non-structured programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Quantum_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Quantum_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Quantum programming is a set of computer programming languages that allow the expression of quantum algorithms using high-level constructs.  The point of quantum languages is not so much to provide a tool for programmers, but to provide tools for researchers to understand better how quantum computation works and how to reason formally about quantum algorithms.One can single out two main groups of quantum programming languages: imperative quantum programming languages and functional quantum programming languages.The most prominent representatives of the first group are QCL and LanQ.Efforts are underway to develop functional programming languages for quantum computing. Examples include Selinger's QPL, and the Haskell-like language QML by Altenkirch and Grattage. Higher-order quantum programming languages, based on lambda calculus, have been proposed by van Tonder, Selinger and Valiron  and by Arrighi and Dowek.Simon Gay's Quantum Programming Languages Survey provides information on the state of research and a comprehensive bibliography of resources about quantum programming as of 2007." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Quantum programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Parallel_programming_model" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Parallel_programming_model" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer software, a parallel programming model is a model for writing parallel programs which can be compiled and executed. The value of a programming model can be judged on its generality: how well a range of different problems can be expressed for a variety of different architectures, and its performance: how efficiently they execute. The implementation of a programming model can take several forms such as libraries invoked from traditional sequential languages, language extensions, or complete new execution models.Consensus around each programming model is important as it enables software expressed within it to be transportable between different architectures.  For sequential programming architectures, the von Neumann model has facilitated this, as it provides an efficient bridge between hardware and software, meaning that high-level languages can be efficiently compiled to it and it can be efficiently implemented in hardware." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Parallel programming model" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Higher-order_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Higher-order_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Higher-order programming is a style of computer programming that uses software components, like functions, modules or objects, as values. It is usually instantiated with, or borrowed from, models of computation such as lambda calculus which make heavy use of higher-order functions.For example, in higher-order programming, one can pass functions as arguments to other functions and functions can be the return value of other functions (such as in macros or for interpreting). This style of programming is mostly used in functional programming, but it can also be very useful in object-oriented programming.  A slightly different interpretation of higher-order programming in the context of object-oriented programming are higher order messages, which let messages have other messages as arguments, rather than functions.Prominent examples of languages supporting this are C#, Java, ECMAScript (ActionScript, JavaScript, JScript), F#, Haskell, Lisp (Common Lisp, Scheme, Clojure, others), Lua, Oz, Perl, Prolog, Python, Ruby, Smalltalk, Scala, ML, and Erlang." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Higher-order programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Aspect-oriented_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Aspect-oriented_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computing, aspect-oriented programming (AOP) is a programming paradigm that aims to increase modularity by allowing the separation of cross-cutting concerns. AOP forms a basis for aspect-oriented software development.AOP includes programming methods and tools that support the modularization of concerns at the level of the source code, while \"aspect-oriented software development\" refers to a whole engineering discipline.Aspect-oriented programming entails breaking down program logic into distinct parts (so-called concerns, cohesive areas of functionality). Nearly all programming paradigms support some level of grouping and encapsulation of concerns into separate, independent entities by providing abstractions (e.g., functions, procedures, modules, classes, methods) that can be used for implementing, abstracting and composing these concerns. Some concerns \"cut across\" multiple abstractions in a program, and defy these forms of implementation. These concerns are called cross-cutting concerns.Logging exemplifies a crosscutting concern because a logging strategy necessarily affects every logged part of the system. Logging thereby crosscuts all logged classes and methods.All AOP implementations have some crosscutting expressions that encapsulate each concern in one place. The difference between implementations lies in the power, safety, and usability of the constructs provided. For example, interceptors that specify the methods to intercept express a limited form of crosscutting, without much support for type-safety or debugging. AspectJ has a number of such expressions and encapsulates them in a special class, an aspect. For example, an aspect can alter the behavior of the base code (the non-aspect part of a program) by applying advice (additional behavior) at various join points (points in a program) specified in a quantification or query called a pointcut (that detects whether a given join point matches). An aspect can also make binary-compatible structural changes to other classes, like adding members or parents." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Aspect-oriented programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Attribute-oriented_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Attribute-oriented_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Attribute-oriented programming (AOP) is a program-level marking technique. Programmers can mark program elements (e.g. classes and methods) to indicate that they maintain application-specific or domain-specific semantics. For example, some programmers may define a \"logging\" attribute and associate it with a method to indicate the method should implement a logging function, while other programmers may define a \"web service\" attribute and associate it with a class to indicate the class should be implemented as a web service. Attributes separate application's core logic (or business logic) from application-specific or domain-specific semantics (e.g. logging and web service functions). By hiding the implementation details of those semantics from program code, attributes increase the level of programming abstraction and reduce programming complexity, resulting in simpler and more readable programs. The program elements associated with attributes are transformed to more detailed programs by a supporting tool (e.g. preprocessor). For example, a preprocessor may insert a logging program into the methods associated with a \"logging\" attribute." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Attribute-oriented programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Automata-based_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Automata-based_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Automata-based programming is a programming paradigm in which the program or its part is thought of as a model of a finite state machine (FSM) or any other (often more complicated) formal automaton (see automata theory). Sometimes a potentially-infinite set of possible states is introduced, and such a set can have a complicated structure, not just an enumeration.FSM-based programming is generally the same, but, formally speaking, doesn't cover all possible variants as FSM stands for finite state machine and automata-based programming doesn't necessarily employ FSMs in the strict sense.The following properties are key indicators for automata-based programming: The time period of the program's execution is clearly separated down to the steps of the automaton. Each of the steps is effectively an execution of a code section (same for all the steps), which has a single entry point. Such a section can be a function or other routine, or just a cycle body. The step section might be divided down to subsection to be executed depending on different states, although this is not necessary. Any communication between the steps is only possible via the explicitly noted set of variables named the state. Between any two steps, the program (or its part created using the automata-based technique) can not have implicit components of its state, such as local (stack) variables' values, return addresses, the current instruction pointer etc. That is, the state of the whole program, taken at any two moments of entering the step of the automaton, can only differ in the values of the variables being considered as the state of the automaton.The whole execution of the automata-based code is a (possibly explicit) cycle of the automaton's steps.Another reason to use the notion of automata-based programming is that the programmer's style of thinking about the program in this technique is very similar to the style of thinking used to solve math-related tasks using Turing machine, Markov algorithm etc." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Automata-based programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Multi-stage_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Multi-stage_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Multi-stage programming (MSP) is a variety of metaprogramming in which compilation is divided into a series of intermediate phases, allowing typesafe run-time code generation.Statically defined types are used to verify that dynamically constructed types are valid and do not violate the type system.In MSP languages, expressions are qualified by notation that specifies the phase at which they are to be evaluated. By allowing the specialization of a program at run-time, MSP can optimize the performance of programs: it can be considered as a form of partial evaluation that performs computations at compile-time as a trade-off to increase the speed of run-time processing.Multi-stage programming languages support constructs similar to the Lisp construct of quotation and eval, except that scoping rules are taken into account." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Multi-stage programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Interactive_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Interactive_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Interactive programming is the procedure of writing parts of a program while it is already active. This focuses on the program text as the main interface for a running process, rather than an interactive application, where the program is designed in development cycles and used thereafter (usually by a so-called \"user\", in distinction to the \"developer\"). Consequently, here, the activity of writing a program becomes part of the program itself. It thus forms a specific instance of interactive computation as an extreme opposite to batch processing, where neither writing the program nor its use happens in an interactive way. The principle of rapid feedback in Extreme Programming is radicalized and becomes more explicit.Synonyms: Live coding, on-the-fly-programming, just in time programming, conversational programming" }	, "label": { "type": "literal", "xml:lang": "en", "value": "Interactive programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Automatic_mutual_exclusion" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Automatic_mutual_exclusion" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Automatic mutual exclusion is a parallel computing programming paradigm in which threads are divided into atomic chunks, and the atomic execution of the chunks automatically parallelized using transactional memory." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Automatic mutual exclusion" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Array_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Array_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, array programming languages (also known as vector or multidimensional languages) generalize operations on scalars to apply transparently to vectors, matrices, and higher-dimensional arrays.Array programming primitives concisely express broad ideas about data manipulation. The level of conciseness can be dramatic in certain cases: it is not uncommon to find array programming language one-liners that require more than a couple of pages of Java code.Modern programming languages that support array programming are commonly used in scientific and engineering settings; these include Fortran 90, MATLAB, TK Solver (as lists), Octave, R, Cilk Plus and the NumPy extension to Python. In these languages, an operation that operates on entire arrays can be called a vectorized operation, regardless of whether it is executed on a vector processor or not." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Array programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Data-driven_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Data-driven_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer programming, data-driven programming is a programming paradigm in which the program statements describe the data to be matched and the processing required rather than defining a sequence of steps to be taken. Standard examples of data-driven languages are the text-processing languages sed and AWK, where the data is a sequence of lines in an input stream \u2013 these are thus also known as line-oriented languages \u2013 and pattern matching is primarily done via regular expressions or line numbers." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Data-driven programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Imperative_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Imperative_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Imperative programming (Necessary Programming) is focused on describing how a program operates.In computer science terminologies, imperative programming is a programming paradigm that describes computation in terms of statements that change a program state. In much the same way that the imperative mood in natural languages expresses commands to take action, imperative programs define sequences of commands for the computer to perform.The term is often used in contrast to declarative programming, which focuses on what the program should accomplish without prescribing how to do it in terms of sequences of actions to be taken." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Imperative programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Metaprogramming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Metaprogramming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Metaprogramming is the writing of computer programs with the ability to treat programs as their data. It means that a program could be designed to read, generate, analyse and/or transform other programs, and even modify itself while running. In some cases, this allows programmers to minimize the number of lines of code to express a solution (hence reducing development time), or it gives programs greater flexibility to efficiently handle new situations without recompilation.The language in which the metaprogram is written is called the metalanguage. The language of the programs that are manipulated is called the object language. The ability of a programming language to be its own metalanguage is called reflection or reflexivity.Reflection is a valuable language feature to facilitate metaprogramming. Having the programming language itself as a first-class data type (as in Lisp, Prolog, SNOBOL, or Rebol) is also very useful; this is known as homoiconicity. Generic programming invokes a metaprogramming facility within a language, in those languages supporting it.Metaprogramming usually works in one of three ways. The first way is to expose the internals of the run-time engine to the programming code through application programming interfaces (APIs). The second approach is dynamic execution of expressions that contain programming commands, often composed from strings, but can also be from other methods using arguments and/or context. Thus, \"programs can write programs.\" Although both approaches can be used in the same language, most languages tend to lean toward one or the other.The third way is to step outside the language entirely. General purpose program transformation systems such as compilers, which accept language descriptions and can carry out arbitrary transformations on those languages, are direct implementations of general metaprogramming. This allows metaprogramming to be applied to virtually any target language without regard to whether that target language has any metaprogramming abilities of its own." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Metaprogramming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Modular_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Modular_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Modular programming is a software design technique that emphasizes separating the functionality of a program into independent, interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired functionality.A module interface expresses the elements that are provided and required by the module. The elements defined in the interface are detectable by other modules. The implementation contains the working code that corresponds to the elements declared in the interface. Modular programming is closely related to structured programming and object-oriented programming, all having the same goal of facilitating construction of large software programs and systems by decomposition into smaller pieces, and all originating around the 1960s. While historically usage of these terms has been inconsistent, today \"modular programming\" refers to high-level decomposition of the code of an entire program into pieces, structured programming to the low-level code use of structured control flow, and object-oriented programming to the data use of objects, a kind of data structure." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Modular programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Programming_paradigm" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Programming_paradigm" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "A programming paradigm is a fundamental style of computer programming, serving as a way of building the structure and elements of computer programs.  Capabilities and styles of various programming languages are defined by their supported programming paradigms; some programming languages are designed to follow only one paradigm, while others support multiple paradigms.Programming paradigms that are often distinguished include imperative, declarative, functional, object-oriented,  procedural, logic and symbolic programming.  With different paradigms, programs can be seen and built in different ways; for example, in object-oriented programming, a program is a collection of objects interacting in explicitly defined ways, while in declarative programming the computer is told only what the problem is, not how to actually solve it." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Programming paradigm" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Stack-oriented_programming_language" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Stack-oriented_programming_language" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "A stack-oriented programming language is one that relies on a stack machine model for passing parameters. Several programming languages fit this description, notably Forth, RPL, PostScript, BibTeX style design language and also many assembly languages (but on a much lower level).Stack-oriented programming languages operate upon one or more stacks, each of which may serve different purposes. Because of this, programming constructs in other programming languages may need to be modified for use in a stack-oriented programming language. Adding to this, some stack-oriented programming languages operate in Reverse Polish or postfix notation - that is, the arguments or parameters for some command are stated before the actual command itself. For example, in RPN, one would say \"2, 3, multiply\" instead of \"multiply, 2, 3\" (prefix or Polish notation) or \"2 multiply 3\" (infix notation)." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Stack-oriented programming language" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Function-level_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Function-level_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, function-level programming refers to one of the two contrasting programming paradigms identified by John Backus in his work on programs as mathematical objects, the other being value-level programming.In his 1977 Turing award lecture, Backus set forth what he considered to be the need to switch to a different philosophy in programming language design:Programming languages appear to be in trouble. Each successive language incorporates, with a little cleaning up, all the features of its predecessors plus a few more. [...] Each new language claims new and fashionable features... but the plain fact is that few languages make programming sufficiently cheaper or more reliable to justify the cost of producing and learning to use them.He designed FP to be the first programming language to specifically support the function-level programming style.A function-level program is variable-free (cf. point-free programming), since program variables, which are essential in value-level definitions, are not needed in function-level programs." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Function-level programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Process-oriented_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Process-oriented_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Process-oriented programming is a programming paradigm that separates the concerns of data structures and the concurrent processes that act upon them. The data structures in this case are typically persistent, complex, and large scale - the subject of general purpose applications, as opposed to specialized processing of specialized data sets seen in high productivity applications (HPC). The model allows the creation of large scale applications that partially share common data sets. Programs are functionally decomposed into parallel processes that create and act upon logically shared data.The paradigm was originally invented for parallel computers in the 1980s, especially computers built with transputer microprocessors by INMOS, or similar architectures. It evolved to meet deficiencies in the message passing paradigm of Occam and enable uniform efficiency when porting applications between distributed memory and shared memory parallel computers. The first example of the paradigm appears in the programming language Ease designed at Yale University in 1990. Similar models have appeared since in the loose combination of SQL databases and objected oriented languages such as Java, often referred to as object-relational models and widely used in large scale distributed systems today. The paradigm is likely to appear on desktop computers as microprocessors increase the number of processors (multicore) per chip." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Process-oriented programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Presenter_First" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Presenter_First" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Presenter First is a software development approach that combines the ideas of the model\u2013view\u2013presenter (MVP) design pattern, test-driven development, and feature-driven development." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Presenter First" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Value_semantics" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Value_semantics" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, having value semantics (also value-type semantics or copy-by-value semantics) means for an object that only its value counts, not its identity. If the concept is fully applied, value semantics implies immutability of the object.The concepts that are used to explain this concept are extensionality, definiteness, substitutivity of identity, unfoldability, and referential transparency." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Value semantics" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Exploratory_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Exploratory_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Exploratory programming is an important part of the software engineering cycle: when a domain is not very well understood or open-ended, or it's not clear what algorithms and data structures might be needed for an implementation, it's useful to be able to interactively develop and debug a program without having to go through the usual constraints of the edit-compile-run-debug cycle. Many languages provide support for exploratory programming via interactivity, dynamicity, and extensibility, such as Cecil, Dylan, Factor, Lisp, Mathematica, Obliq, Oz, Prolog, Python, REBOL, Perl, Ruby, Self, Smalltalk and Tcl." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Exploratory programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Automatic_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Automatic_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, the term automatic programming identifies a type of computer programming in which some mechanism generates a computer program to allow human programmers to write the code at a higher abstraction level.There has been little agreement on the precise definition of automatic programming, mostly because its meaning has changed over time. David Parnas, tracing the history of \"automatic programming\" in published research, noted that in the 1940s it described automation of the manual process of punching paper tape. Later it referred to translation of high-level programming languages like Fortran and ALGOL. In fact, one of the earliest programs identifiable as a compiler was called Autocode. Parnas concluded that \"automatic programming has always been a euphemism for programming in a higher-level language than was then available to the programmer.\"" }	, "label": { "type": "literal", "xml:lang": "en", "value": "Automatic programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Flow_chart_language" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Flow_chart_language" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Flow chart language (FCL) is a simple imperative programming language designed for the purposes of explaining fundamental concepts of program analysis and specialization, in particular, partial evaluation. The language was first presented in 1989 by Carsten K. Gomard and Neil D. Jones. It later resurfaced in their book with Peter Sestoft in 1993, and in John Hatcliff's lecture notes in 1998. The below describes FCL as it appeared in John Hatcliff's lecture notes.FCL is an imperative programming language close to the way a Von Neumann computer executes a program. A program is executed sequentially by following a sequence of commands, while maintaining an implicit state, i.e. the global memory. FCL has no concept of procedures, but does provide conditional and unconditional jumps. FCL lives up to its name as the abstract call-graph of an FCL program is a straightforward flow chart.An FCL program takes as input a finite series of named values as parameters, and produces a value as a result." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Flow chart language" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Mirror_(programming)" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Mirror_(programming)" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In Computer programming, a Mirror is a Reflection mechanism that is completely decoupled from the object whose structure is being introspected. This is as opposed to traditional reflection, for example in Java, where one introspects an object using methods from the object itself (e.g. getClass()).Mirrors adhere to the qualities of encapsulation, stratification, and ontological correspondence. [1]" }	, "label": { "type": "literal", "xml:lang": "en", "value": "Mirror (programming)" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Stream_processing" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Stream_processing" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Stream processing is a computer programming paradigm, related to SIMD (single instruction, multiple data), that allows some applications to more easily exploit a limited form of parallel processing. Such applications can use multiple computational units, such as the FPUs on a GPU or field programmable gate arrays (FPGAs), without explicitly managing allocation, synchronization, or communication among those units.The stream processing paradigm simplifies parallel software and hardware by restricting the parallel computation that can be performed. Given a set of data (a stream), a series of operations (kernel functions) is applied to each element in the stream. Uniform streaming, where one kernel function is applied to all elements in the stream, is typical. Kernel functions are usually pipelined, and local on-chip memory is reused to minimize external memory bandwidth. Since the kernel and stream abstractions expose data dependencies, compiler tools can fully automate and optimize on-chip management tasks. Stream processing hardware can use scoreboarding, for example, to launch DMAs at runtime, when dependencies become known. The elimination of manual DMA management reduces software complexity, and the elimination of hardware caches reduces the amount of the area not dedicated to computational units such as ALUs.During the 1980s stream processing was explored within dataflow programming. An example is the language SISAL (Streams and Iteration in a Single Assignment Language)." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Stream processing" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Write_once,_run_anywhere" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Write_once,_run_anywhere" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "\"Write once, run anywhere\" (WORA), or sometimes write once, run everywhere (WORE), is a slogan created by Sun Microsystems to illustrate the cross-platform benefits of the Java language. Ideally, this means Java can be developed on any device, compiled into a standard bytecode and be expected to run on any device equipped with a Java virtual machine (JVM).  The installation of a JVM or Java interpreter on chips, devices or software packages has become an industry standard practice.This means a programmer can develop code on a PC and can expect it to run on Java enabled cell phones, as well as on routers and mainframes equipped with Java, without any adjustments. This is intended to save software developers the effort of writing a different version of their software for each platform or operating system they intend to deploy on.This idea originated as early as in the late 1970s, when the UCSD Pascal system was developed to produce and interpret p-code.  UCSD Pascal (along with the Smalltalk virtual machine) was a key influence on the design of the Java virtual machine, as is cited by James Gosling.The catch is that since there are multiple JVM implementations, on top of a wide variety of different operating systems such as Windows, Linux, Solaris, NetWare, HP-UX, and Mac OS, there can be subtle differences in how a program may execute on each JVM/OS combination, which may require an application to be tested on various target platforms.  This has given rise to a joke among Java developers, \"Write Once, Debug Everywhere\"." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Write once, run anywhere" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Extensible_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Extensible_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Extensible programming is a term used in computer science to describe a style of computer programming that focuses on mechanisms to extend the programming language, compiler and runtime environment.  Extensible programming languages, supporting this style of programming, were an active area of work in the 1960s, but the movement was marginalized in the 1970s.  Extensible programming has become a topic of renewed interest in the 21st century." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Extensible programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Scientific_language" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Scientific_language" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer programming, a scientific language is a programming language optimized for the use of mathematical formulas and matrices. Although these functions can be performed using any language, they are more easily expressed in scientific languages. Scientific languages include ALGOL, FORTRAN, and APL.In other fields, scientific language is loosely defined as being grammatically correct, and giving concise and correct information." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Scientific language" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Filter_(software)" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Filter_(software)" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "A filter is a computer program or subroutine to process a stream, producing another stream. While a single filter can be used individually, they are frequently strung together to form a pipeline.Some operating systems such as Unix are rich with filter programs. Windows 7 and later are also rich with filters, as they include Windows PowerShell. In comparison, however, few filters are built into cmd.exe (the original command-line interface of Windows), most of which have significant enhancements relative to the similar filter commands that were available in MS-DOS. OS X includes filters from its underlying Unix base but also has Automator, which allows filters (known as \"Actions\") to be strung together to form a pipeline." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Filter (software)" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Hop_(software)" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Hop_(software)" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Hop is a Lisp-like programming language by Manuel Serrano for web 2.0 and also the name of the web broker (server and proxy) that implements this language. It is written in Bigloo Scheme. It is a project funded by INRIA." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Hop (software)" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Object-oriented_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Object-oriented_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Object-oriented programming (OOP) is a programming paradigm based on the concept of \"objects\", which are data structures that contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods. A distinguishing feature of objects is that an object's procedures can access and often modify the data fields of the object with which they are associated (objects have a notion of \"this\"). In object-oriented programming, computer programs are designed by making them out of objects that interact with one another. There is significant diversity in object-oriented programming, but most popular languages are class-based, meaning that objects are instances of classes, which typically also determines their type.Many of the most widely used programming languages are multi-paradigm programming languages that support object-oriented programming to a greater or lesser degree, typically in combination with imperative, procedural programming. Significant object-oriented languages include C++, Objective-C, Smalltalk, Delphi, Java, C#, Perl, Python, Ruby and PHP." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Object-oriented programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Organic_computing" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Organic_computing" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Organic computing is a form of biologically-inspired computing with organic properties. It has emerged recently as a vision for future information processing systems. Organic Computing is based on the insight that we will soon be surrounded by large collections of autonomous systems, which are equipped with sensors and actuators, aware of their environment, communicate freely, and organise themselves in order to perform the actions and services that seem to be required. The presence of networks of intelligent systems in our environment opens new application areas but, at the same time, bears the problem of their controllability. Hence, we have to construct such systems \u2014 which we increasingly depend on \u2014 as robust, safe, flexible, and trustworthy as possible. In particular, a strong orientation towards human needs as opposed to a pure implementation of the technologically possible seems absolutely central. In order to achieve these goals, our technical systems will have to act more independently, flexibly, and autonomously, i.e. they will have to exhibit lifelike properties. We call such systems \"organic\". Hence, an \"Organic Computing System\" is a technical system which adapts dynamically to exogenous and endogenous change. It is characterized by self-X or self-* properties:  self-organization,  self-configuration (auto-configuration),  self-optimization (automated optimization),  self-healing,  self-protection (automated computer security),  self-explaining, and context-awareness. The vision of Organic Computing and its fundamental concepts arose independently in different research areas like Neuroscience, Molecular Biology and Computer Engineering. It can be seen as an extension of the Autonomic computing vision of IBM. Self-organizing systems have been studied for quite some time by mathematicians, sociologists, physicists, economists, and computer scientists, but so far almost exclusively based on strongly simplified artificial models. Central aspects of Organic Computing systems have been and will be inspired by an analysis of information processing in biological systems. Organic computing can also be defined by biological processing systems. The ever expanding power of the processor(silicon based) will eventually hit a physical limit, due to the fact that you can make a, correctly functioning, silicon chip only so small. Using Organic compounds, not much different from the brain tissue that controls us, will be the only way to effectively continue growing our computing infrastructure in the future." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Organic computing" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Pipeline_(software)" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Pipeline_(software)" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In software engineering, a pipeline consists of a chain of processing elements (processes, threads, coroutines, etc.), arranged so that the output of each element is the input of the next; the name is by analogy to a physical pipeline. Usually some amount of buffering is provided between consecutive elements. The information that flows in these pipelines is often a stream of records, bytes or bits, and the elements of a pipeline may be called filters; this is also called the pipes and filters design pattern. Connecting elements into a pipeline is analogous to function composition.Narrowly speaking, a pipeline is linear and one-directional, though sometimes the term is applied to more general flows. For example, a primarily one-directional pipeline may have some communication in the other direction, known as a return channel or backchannel, as in the lexer hack, or a pipeline may be fully bi-directional. Flows with one-directional tree and directed acyclic graph topologies behave similarly to (linear) pipelines \u2013 the lack of cycles makes them simple \u2013 and thus may be loosely referred to as \"pipelines\"." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Pipeline (software)" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Scripting_language" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Scripting_language" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "A scripting language or script language is a programming language that supports scripts, programs written for a special run-time environment that can interpret (rather than compile) and automate the execution of tasks that could alternatively be executed one-by-one by a human operator. Environments that can be automated through scripting include software applications, web pages within a web browser, the shells of operating systems (OS), and embedded systems. A scripting language can be viewed as a domain-specific language for a particular environment; in the case of scripting an application, this is also known as an extension language. Scripting languages are also sometimes referred to as very high-level programming languages, as they operate at a high level of abstraction, or as control languages, particularly for job control languages on mainframes.The term \"scripting language\" is also used loosely to refer to dynamic high-level general-purpose language, such as Perl, Tcl, and Python, with the term \"script\" often used for small programs (up to a few thousand lines of code) in such languages, or in domain-specific languages such as the text-processing languages sed and AWK. Some of these languages were originally developed for use within a particular environment, and later developed into portable domain-specific or general-purpose languages.Conversely, many general-purpose languages have dialects that are used as scripting languages. This article discusses scripting languages in the narrow sense of languages for a specific environment; dynamic, general-purpose, and high-level languages are discussed at those articles.The spectrum of scripting languages ranges from very small and highly domain-specific languages to general-purpose programming languages used for scripting. Standard examples of scripting languages for specific environments include: Bash, for the Unix or Unix-like operating systems; ECMAScript (JavaScript), for web browsers; and Visual Basic for Applications, for Microsoft Office applications. Lua is a language designed and widely used as an extension language. Python is a general-purpose language that is also commonly used as an extension language, while ECMAScript is still primarily a scripting language for web browsers, but is also used as a general-purpose language. The Emacs Lisp dialect of Lisp (for the Emacs editor) and the Visual Basic for Applications dialect of Visual Basic are examples of scripting language dialects of general-purpose languages. Some game systems, notably the Trainz franchise of Railroad simulators have been extensively extended in functionality by scripting extensions." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Scripting language" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Subject_(programming)" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Subject_(programming)" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer programming within the subject-oriented programming paradigm, subjects are a way to separate concerns. For example, in a Shape class with two methods Draw() and Move(), each method would be considered a subject." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Subject (programming)" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Constraint_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Constraint_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, constraint programming is a programming paradigm wherein relations between variables are stated in the form of constraints. Constraints differ from the common primitives of imperative programming languages in that they do not specify a step or sequence of steps to execute, but rather the properties of a solution to be found. This makes constraint programming a form of declarative programming. The constraints used in constraint programming are of various kinds: those used in constraint satisfaction problems (e.g. \"A or B is true\"), those solved by the simplex algorithm (e.g. \"x \u2264 5\"), and others. Constraints are usually embedded within a programming language or provided via separate software libraries.Constraint programming can be expressed in the form of constraint logic programming, which embeds constraints into a logic program. This variant of logic programming is due to Jaffar and Lassez, who extended in 1987 a specific class of constraints that were introduced in Prolog II. The first implementations of constraint logic programming were Prolog III, CLP(R), and CHIP.Instead of logic programming, constraints can be mixed with functional programming, term rewriting, and imperative languages.Programming languages with built-in support for constraints include Oz (functional programming) and Kaleidoscope (imperative programming). Mostly, constraints are implemented in imperative languages via constraint solving toolkits, which are separate libraries for an existing imperative language." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Constraint programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/End-to-end_principle" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/End-to-end_principle" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "The end-to-end principle is a classic design principle in computer networking, first explicitly articulated in a 1981 conference paper by  Saltzer, Reed, and Clark. The end-to-end principle states that in a general-purpose network, application-specific functions ought to reside in the end hosts of a network rather than in intermediary nodes, provided that they can be implemented \"completely and correctly\" in the end hosts. The principle goes back to Paul Baran's 1960's work on obtaining reliability from unreliable parts; the basic intuition is that the payoffs from adding functions to a simple network quickly diminish, especially in cases where the end hosts have to re-implement those functions themselves for reasons of completeness and correctness. Furthermore, as implementing any specific function incurs some resource penalties regardless of whether the function is used or not, implementing a specific function in the network distributes these penalties among all clients, regardless of whether they use that function or not.The canonical example for the end-to-end principle is that of an arbitrarily reliable file transfer between two end-points in a distributed network of some nontrivial size:  The only way two end-points can obtain a completely reliable transfer is by transmitting and acknowledging a checksum for the entire data stream; in such a setting, lesser checksum and acknowledgement (ACK/NACK) protocols are justified only for the purpose of optimizing performance - they are useful to the vast majority of clients, but are not enough to fulfil the reliability requirement of this particular application. Thorough checksum is hence done at the end-points, and the network maintains a relatively low level of complexity and reasonable performance for all clients.In debates about network neutrality, a common interpretation of the end-to-end principle is that it implies a neutral, or \"dumb\" network." }	, "label": { "type": "literal", "xml:lang": "en", "value": "End-to-end principle" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Presentation%E2%80%93abstraction%E2%80%93control" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Presentation\u2013abstraction\u2013control" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Presentation\u2013abstraction\u2013control (PAC) is a software architectural pattern. It is an interaction-oriented software architecture, and is somewhat similar to model\u2013view\u2013controller (MVC) in that it separates an interactive system into three types of components responsible for specific aspects of the application's functionality. The abstraction component retrieves and processes the data, the presentation component formats the visual and audio presentation of data, and the control component handles things such as the flow of control and communication between the other two components.In contrast to MVC, PAC is used as a hierarchical structure of agents, each consisting of a triad of presentation, abstraction and control parts. The agents (or triads) communicate with each other only through the control part of each triad. It also differs from MVC in that within each triad, it completely insulates the presentation (view in MVC) and the abstraction (model in MVC). This provides the option to separately multithread the model and view which can give the user experience of very short program start times, as the user interface (presentation) can be shown before the abstraction has fully initialized." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Presentation\u2013abstraction\u2013control" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Programming_in_the_large_and_programming_in_the_small" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Programming_in_the_large_and_programming_in_the_small" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In software engineering, programming in the large and programming in the small describe two different approaches to writing software.  The terms were coined by Frank DeRemer and Hans Kron in their 1975 paper \"Programming-in-the-large versus programming-in-the-small\" A similar, later distinction is Ousterhout's dichotomy between system programming languages (for components) and scripting languages for glue code, connecting components.Fred Brooks identifies that the way an individual program is created is different from how a programming systems product is created.  The former likely does one relatively simple task well.  It is probably coded by a single engineer, is complete in itself, and is ready to run on the system on which it was developed.  The programming activity was probably fairly short-lived as simple tasks are quick and easy to complete.  This is the endeavor that DeRemer and Kron describe as programming in the small.Compare with the activities associated with a programming systems project, again as identified by Brooks.  Such a project is typified by medium-sized or large industrial teams working on the project for many months to several years.  The project is likely to be split up into several or hundreds of separate modules which individually are of a similar complexity to the individual programs described above.  However, each module will define an interface to its surrounding modules.Brooks describes how programming systems projects are typically run as formal projects that follow industry best practices and will comprise testing, documentation and ongoing maintenance activities as well as activities to ensure that the product is generalized to work in different scenarios including on systems other than the development systems on which it was created.DeRemer and Kron have this to say about programming in the large vs in the small (taken from the abstract of their paper - see the references section, below): \"By large programs we mean systems consisting of many small programs (modules), possibly written by different people. We need languages for programming-in-the-small, i.e. languages not unlike the common programming languages of today, for writing modules. We also need a \u201Cmodule interconnection language\u201D for knitting those modules together into an integrated whole and for providing an overview that formally records the intent of the programmer(s) and that can be checked for consistency by a compiler. We explore the software reliability aspects of such an interconnection language. Emphasis is placed on facilities for information hiding and for defining layers of virtual machines.\"" }	, "label": { "type": "literal", "xml:lang": "en", "value": "Programming in the large and programming in the small" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Functional_logic_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Functional_logic_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Functional logic programming is the combination, in a single programming language, of the paradigms of functional programming (including higher-order programming) and logic programming (non-deterministic programming, unification). This style of programming was pioneered in \u03BBProlog in the 1990s. Other, newer functional logic programming languages include Curry and Mercury." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Functional logic programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Data-directed_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Data-directed_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Data-directed programming is a programming technique mentioned in Structure and Interpretation of Computer Programs. Essentially it is a \"dispatch\" technique on procedures for integrating separately developed data-type (e.g., class) modules, based on the programmers manual setup of dynamic tables for procedure access.  In modern object-oriented programming languages it is implemented as polymorphism." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Data-directed programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/JetBrains_MPS" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/JetBrains_MPS" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "JetBrains MPS is a metaprogramming system which is being developed by JetBrains. It implements language-oriented programming. MPS is an environment for language definition, a language workbench, and integrated development environment (IDE) for such languages." }	, "label": { "type": "literal", "xml:lang": "en", "value": "JetBrains MPS" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Service-oriented_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Service-oriented_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Service-oriented programming (SOP) is a programming paradigm that uses \"services\" as the unit of computer work, to design and implement integrated business applications and mission critical software programs. Services can represent steps of business processes and thus one of the main applications of this paradigm is the cost-effective delivery of standalone or composite business applications that can \"integrate from the inside-out\"" }	, "label": { "type": "literal", "xml:lang": "en", "value": "Service-oriented programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Subject-oriented_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Subject-oriented_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computing, Subject-Oriented Programming is an object-oriented software paradigm in which the state (fields) and behavior (methods) of objects are not seen as intrinsic to the objects themselves, but are provided by various subjective perceptions (\u201Csubjects\u201D) of the objects. The term and concepts were first published in September 1993 in a conference paper which was later recognized as being one of the three most influential papers to be presented at the conference between 1986 and 1996. As illustrated in that paper, an analogy is made with the contrast between the philosophical views of Plato and Kant with respect to the characteristics of \u201Creal\u201D objects, but applied to software ones. For example, while we may all perceive a tree as having a measurable height, weight, leaf-mass, etc., from the point of view of a bird, a tree may also have measures of relative value for food or nesting purposes, or from the point of view of a tax-assessor, it may have a certain taxable value in a given year. Neither the bird\u2019s nor the tax-assessor\u2019s additional state information need be seen as intrinsic to the tree, but are added by the perceptions of the bird and tax-assessor, and from Kant\u2019s analysis, the same may be true even of characteristics we think of as intrinsic.Subject-oriented programming advocates the organization of the classes that describe objects into \u201Csubjects\u201D, which may be composed to form larger subjects. At points of access to fields or methods, several subjects\u2019 contributions may be composed. These points were characterized as the join-points of the subjects. For example, if a tree is cut-down, the methods involved may need to join behavior in the bird and tax-assessor\u2019s subjects with that of the tree\u2019s own. It is therefore fundamentally a view of the compositional nature of software development, as opposed to the algorithmic (procedural) or representation-hiding (object) nature." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Subject-oriented programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Abstraction_(computer_science)" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Abstraction_(computer_science)" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, abstraction is a technique for managing complexity of computer systems. It works by establishing a level of complexity on which a person interacts with the system, suppressing the more complex details below the current level. The programmer works with an idealized interface (usually well defined) and can add additional levels of functionality that would otherwise be too complex to handle. For example, a programmer writing code that involves numerical operations may not be interested in the way numbers are represented in the underlying hardware (eg. whether they're 16 bit or 32 bit integers), and where those details have been suppressed it can be said that they were abstracted away, leaving simply numbers with which the programmer can work.In addition, a task of sending an email message across continents would be extremely complex if you start with a piece of optic cable and basic hardware components. By using layers of complexity that have been created to abstract away the physical cables, network layout and presenting the programmer with a virtual data channel, this task is manageable.Abstraction can apply to control or to data: Control abstraction is the abstraction of actions while data abstraction is that of data structures. Control abstraction involves the use of subprograms and related concepts control flows Data abstraction allows handling data bits in meaningful ways. For example, it is the basic motivation behind datatype.One can view the notion of an object as a way to combine abstractions of data and code.The same abstract definition can be used as a common interface for a family of objects with different implementations and behaviors but which share the same meaning. The inheritance mechanism in object-oriented programming can be used to define an abstract class as the common interface.The recommendation that programmers use abstractions whenever suitable in order to avoid duplication (usually of code) is known as the abstraction principle. The requirement that a programming language provide suitable abstractions is also called the abstraction principle." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Abstraction (computer science)" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Prototype-based_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Prototype-based_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Prototype-based programming is a style of object-oriented programming in which behaviour reuse (known as inheritance) is performed via a process of cloning existing objects that serve as prototypes. This model can also be known as prototypal, prototype-oriented, classless, or instance-based programming. Delegation is the language feature that supports prototype-based programming.A fruit bowl serves as one example. A \"fruit\" object would represent the properties and functionality of fruit in general. A \"banana\" object would be cloned from the \"fruit\" object, and would also be extended to include general properties specific to bananas. Each individual \"banana\" object would be cloned from the generic \"banana\" object.The first prototype-oriented programming language was Self, developed by David Ungar and Randall Smith in the mid-1980s to research topics in object-oriented language design. Since the late 1990s, the classless paradigm has grown increasingly popular.  Some current prototype-oriented languages are JavaScript (and other ECMAScript implementations, JScript and Flash's ActionScript 1.0), Lua, Cecil, NewtonScript, Io, MOO, REBOL,  Lisaac and AHk." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Prototype-based programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Semantic-oriented_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Semantic-oriented_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Semantic-oriented programming (SOP) is a programming paradigm in which the programmer formulizes the logic of a domain by means of semantic structures. Similar to Concept programming and Concept-oriented programming." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Semantic-oriented programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Sequence_point" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Sequence_point" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "A sequence point defines any point in a computer program's execution at which it is guaranteed that all side effects of previous evaluations will have been performed, and no side effects from subsequent evaluations have yet been performed. A sequence point is a point in program execution at which all side effects are evaluated before going on to the next step. They are often mentioned in reference to C and C++, because they are a core concept for determining the validity and, if valid, the possible results of expressions. Adding more sequence points is sometimes necessary to make an expression defined and to ensure a single valid order of evaluation.With C++11, usage of the term sequence point has been replaced sequencing:sequenced before.sequenced after.indeterminately sequenced (one of the above but which is not defined).unsequenced.The execution of unsequenced evaluations can overlap, catastrophically if a write to an object is unsequenced with regard to another access to the same." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Sequence point" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Declarative_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Declarative_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, declarative programming is a programming paradigm, a style of building the structure and elements of computer programs, that expresses the logic of a computation without describing its control flow. Many languages applying this style attempt to minimize or eliminate side effects by describing what the program should accomplish in terms of the problem domain, rather than describing how to go about accomplishing it as a sequence of the programming language primitives (the how is left up to the language's implementation). This is in contrast with imperative programming, in which algorithms are implemented in terms of explicit steps.Declarative programming often considers programs as theories of a formal logic, and computations as deductions in that logic space. Declarative programming may greatly simplify writing parallel programs.Common declarative languages include those of database query languages (e.g., SQL, XQuery), regular expressions, logic programming, functional programming, and configuration management systems." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Declarative programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Strict_programming_language" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Strict_programming_language" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "A strict programming language is one in which only strict functions (functions whose parameters must be evaluated completely before they may be called) may be defined by the user. A non-strict programming language allows the user to define non-strict functions, and hence may allow lazy evaluation." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Strict programming language" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Metalinguistic_abstraction" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Metalinguistic_abstraction" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, metalinguistic abstraction is the process of solving complex problems by creating a new language or vocabulary to better understand the problem space. It is a recurring theme in the seminal MIT textbook, the Structure and Interpretation of Computer Programs, which uses Scheme as a framework for constructing new languages." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Metalinguistic abstraction" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Higher_order_message" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Higher_order_message" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "A higher order message (HOM) in a computer programming language is a form of higher-order programming that allows messages that have other messages as arguments. The concept was introduced at MacHack 2003 by Marcel Weiher and presented in a more complete form in 2005 by Marcel Weiher and St\u00E9phane Ducasse. Loops can be written without naming the collections looped over, higher order messages can be viewed as a form of point-free or tacit programming." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Higher order message" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Typeful_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Typeful_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, typeful programming, also known as type directed programming, is a programming style identified by widespread use of type information handled through mechanical typechecking techniques. The concept was introduced in a paper of the same name by Luca Cardelli in 1991.The Haskell programming language is said to be typeful." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Typeful programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Policy-based_design" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Policy-based_design" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Policy-based design, also known as policy-based class design or policy-based programming, is a computer programming paradigm based on an idiom for C++ known as policies.  It has been described as a compile-time variant of the strategy pattern, and has connections with C++ template metaprogramming.  It was first popularized by Andrei Alexandrescu with his 2001 book Modern C++ Design and his column Generic<Programming> in the C/C++ Users Journal.Although the technique could theoretically be applied to other languages, it is currently closely associated with C++, and depends on the particular feature set of that language.  Furthermore, even in C++ it requires a compiler with highly robust support for templates, which wasn't common before about 2003." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Policy-based design" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Concurrent_object-oriented_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Concurrent_object-oriented_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Concurrent object-oriented programming is a programming paradigm which combines object-oriented programming (OOP) together with concurrency. While numerous programming languages, such as Java, combine OOP with concurrency mechanisms like threads, the phrase \"concurrent object-oriented programming\" primarily refers to systems where objects themselves are a concurrency primitive, such as when objects are combined with the actor model." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Concurrent object-oriented programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Comparison_of_programming_paradigms" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Comparison_of_programming_paradigms" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "This article attempts to set out the various similarities and differences between the various programming paradigms as a summary in both graphical and tabular format with links to the separate discussions concerning these similarities and differences in extant Wikipedia articles." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Comparison of programming paradigms" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Language-oriented_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Language-oriented_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Language-oriented programming (LOP) is a style of computer programming in which, rather than solving problems in general-purpose programming languages, the programmer creates one or more domain-specific languages for the problem first, and solves the problem in those languages. This concept is described in detail in the paper by Martin Ward entitledLanguage Oriented Programming published in Software - Concepts and Tools, Vol.15, No.4, pp 147-161, 1994and in the article by Sergey Dmitriev entitled Language Oriented Programming: The Next Programming Paradigm." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Language-oriented programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Program_synthesis" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Program_synthesis" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Program synthesis is a special form of automatic programming that is most often paired with a technique for formal verification. The goal is to construct automatically a program that provably satisfies a given high-level specification. In contrast to other automatic programming techniques, the specifications are usually non-algorithmic statements of an appropriate logical calculus." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Program synthesis" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Inferential_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Inferential_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In ordinary computer programming, the programmer keeps the program's intended results in mind and painstakingly constructs a computer program to achieve those results. Inferential programming refers to (still mostly hypothetical) techniques and technologies enabling the inverse. Inferential programming would allow the programmer to describe the intended result to the computer using a metaphor such as a fitness function, a test specification, or a logical specification and then the computer would construct its own program to meet the supplied criteria.During the 1980s, approaches to achieve inferential programming mostly revolved around techniques for logical inference. Today the term is sometimes used in connection with evolutionary computation techniques that enable the computer to evolve a solution in response to a problem posed as a fitness or reward function." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Inferential programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/FOSD_origami" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/FOSD_origami" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Feature Oriented Programming or Feature Oriented Software Development (FOSD) is a general paradigm for program synthesis in software product lines.  Please read the Feature Oriented Programming page that explains how an FOSD model of a domain is a tuple of 0-ary functions (called values) and a set of 1-ary (unary) functions called features. This page discusses multidimensional generalizations of FOSD models, which are important for compact specifications of complex programs." }	, "label": { "type": "literal", "xml:lang": "en", "value": "FOSD origami" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Standard_swap" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Standard_swap" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer science, the standard swap or three point turn is a programming paradigm that exchanges the values of two variables.By using a third variable, whose value is otherwise of no concern, to hold the value of the first, and then assigning the second's to the first, and the third's back to the second, the values of the first two are swapped.For example: let temp = b let b = a let a = tempIn modern CPUs this is accomplished on the processor itself, in a single machine instruction, rather than having to go through RAM." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Standard swap" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Fate-sharing" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Fate-sharing" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Fate-sharing is an engineering design philosophy where related parts of a system are yoked together, so that they either fail together or not at all. Fate-sharing is an example of the end-to-end principle. The term \"fate-sharing\" was defined by David D. Clark in his 1988 paper \"The Design Philosophy of the DARPA Internet Protocols\" as follows: The fate-sharing model suggests that it is acceptable to lose the state information associated with an entity if, at the same time, the entity itself is lost. Specifically, information about transport level synchronization is stored in the host which is attached to the net and using its communication service.A good example of fate-sharing is the transmission of routing messages in routing protocols such as BGP, where the failure of a link or link interface automatically has the effect of terminating routing announcements through that interface, ultimately resulting in the tearing down of the state for that route at each end of the link. Similar considerations apply to TCP." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Fate-sharing" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Invariant-based_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Invariant-based_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Invariant-based programming is a programming methodology where specifications and invariants are written before the actual program statements. Writing down the invariants during the programming process has a number of advantages: it requires the programmer to make his intentions about the program behavior explicit before actually implementing it, and invariants can be evaluated dynamically during execution to catch common programming errors. Furthermore, if strong enough, invariants can be used to prove the correctness of the program based on the formal semantics of program statements. A combined programming and specification language, connected to a powerful formal proof system, will generally be required for full verification of non-trivial programs. In this case a high degree of automation of proofs is also possible.In most existing programming languages the main organizing structures are control flow blocks such as for loops, while loops and if statements. Such languages may not be ideal for invariants-first programming, since they force the programmer to make decisions about control flow before writing the invariants. Furthermore, most programming languages do not have good support for writing specifications and invariants, since they lack quantifier operators and one can typically not express higher order properties.The idea of developing the program together with its proof originated from E.W. Dijkstra. Actually writing invariants before program statements has been considered in a number of different forms by M.H. van Emden, J.C. Reynolds and R-J Back." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Invariant-based programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Humus_(programming_language)" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Humus_(programming_language)" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Humus is a  programming language based on Actor model." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Humus (programming language)" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Dataflow_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Dataflow_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "In computer programming, dataflow programming is a programming paradigm that models a program as a directed graph of the data flowing between operations, thus implementing dataflow principles and architecture. Dataflow programming languages share some features of functional languages, and were generally developed in order to bring some functional concepts to a language more suitable for numeric processing. Some authors use the term Datastream instead of Dataflow to avoid confusion with Dataflow Computing or Dataflow architecture, based on an indeterministic machine paradigm." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Dataflow programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/Concept_programming" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/Concept_programming" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "Concept programming is a programming paradigm focusing on how concepts, that live in the programmer's mind, translate into representations that are found in the code space. This approach was introduced in 2001 by Christophe de Dinechin with the XL Programming Language." }	, "label": { "type": "literal", "xml:lang": "en", "value": "Concept programming" }},
    { "paradigm": { "type": "uri", "value": "http://dbpedia.org/resource/MINASWAN" }	, "wpage": { "type": "uri", "value": "http://en.wikipedia.org/wiki/MINASWAN" }	, "abstract": { "type": "literal", "xml:lang": "en", "value": "\"Matz is Nice And So We Are Nice\" (MINASWAN or MINSWAN) is a  Ruby programming motto designed to promote positivity and goodwill among community members." }	, "label": { "type": "literal", "xml:lang": "en", "value": "MINASWAN" }} ] } }